<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>Справочник Celesta</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Справочник Celesta</h1>
<div id="toc" class="toc2">
<div id="toctitle">Содержание</div>
<ul class="sectlevel1">
<li><a href="#_справочник_celesta">1. Справочник Celesta</a>
<ul class="sectlevel2">
<li><a href="#_введение_и_основные_понятия">1.1. Введение и основные понятия</a>
<ul class="sectlevel3">
<li><a href="#_введение">1.1.1. Введение</a></li>
<li><a href="#celesta_vocabulary">1.1.2. Основные понятия</a></li>
</ul>
</li>
<li><a href="#_запуск_celesta_и_авто_обновление_бд">1.2. Запуск Celesta и авто-обновление БД</a>
<ul class="sectlevel3">
<li><a href="#_инициализация_celesta">1.2.1. Инициализация Celesta</a></li>
<li><a href="#_автоматическая_миграция_структуры_данных">1.2.2. Автоматическая миграция структуры данных</a></li>
</ul>
</li>
<li><a href="#basic_settings_section">1.3. Базовая настройка Celesta</a></li>
<li><a href="#system_tables">1.4. Системные таблицы Celesta</a>
<ul class="sectlevel3">
<li><a href="#_структура_системной_гранулы_celesta">1.4.1. Структура системной гранулы "celesta"</a></li>
<li><a href="#celesta_grains_table">1.4.2. Таблица celesta.grains</a></li>
<li><a href="#_система_распределения_прав_доступа">1.4.3. Система распределения прав доступа.</a></li>
<li><a href="#_система_логирования">1.4.4. Система логирования</a></li>
<li><a href="#_система_профилирования">1.4.5. Система профилирования</a></li>
</ul>
</li>
<li><a href="#CelestaSQL">1.5. Язык CelestaSQL</a>
<ul class="sectlevel3">
<li><a href="#_язык_celestasql_определения_объектов_базы_данных">1.5.1. Язык CelestaSQL определения объектов базы данных</a></li>
<li><a href="#_комментарии_в_языке_celestasql">1.5.2. Комментарии в языке CelestaSQL</a></li>
<li><a href="#_идентификаторы_объектов_в_языке_celestasql">1.5.3. Идентификаторы объектов в языке CelestaSQL</a></li>
<li><a href="#create_schema_statement">1.5.4. Конструкция CREATE SCHEMA (GRAIN)</a></li>
<li><a href="#create_sequence_statement">1.5.5. Конструкция CREATE SEQUENCE</a></li>
<li><a href="#create_table_statement">1.5.6. Конструкция CREATE TABLE</a></li>
<li><a href="#create_index_statement">1.5.7. Конструкция CREATE INDEX</a></li>
<li><a href="#create_view_statement">1.5.8. Конструкция CREATE VIEW</a></li>
<li><a href="#create_materialized_view_statement">1.5.9. Конструкция CREATE MATERIALIZED VIEW</a></li>
<li><a href="#create_function_statement">1.5.10. Конструкция CREATE FUNCTION</a></li>
</ul>
</li>
<li><a href="#_celestadoc">1.6. CelestaDoc</a></li>
<li><a href="#_контекст_вызова">1.7. Контекст вызова</a></li>
<li><a href="#_работа_с_данными_через_классы_доступа_к_данным">1.8. Работа с данными через классы доступа к данным</a>
<ul class="sectlevel3">
<li><a href="#_классы_доступа_и_их_стандартные_методы">1.8.1. Классы доступа и их стандартные методы</a></li>
<li><a href="#_использование_метода_setfilter">1.8.2. Использование метода setFilter</a></li>
<li><a href="#_использование_метода_setin">1.8.3. Использование метода setIn</a></li>
<li><a href="#_триггеры">1.8.4. Триггеры</a></li>
<li><a href="#_объект_xrec">1.8.5. Объект xRec</a></li>
<li><a href="#_класс_sequence">1.8.6. Класс Sequence</a></li>
<li><a href="#_распределение_прав_доступа_и_протоколирование_изменений">1.8.7. Распределение прав доступа и протоколирование изменений</a></li>
</ul>
</li>
<li><a href="#BLOB_fields">1.9. BLOB-поля</a></li>
<li><a href="#Option_fields">1.10. Option-поля</a></li>
<li><a href="#Lost_updates_protection">1.11. Защита от потерянных обновлений</a>
<ul class="sectlevel3">
<li><a href="#_что_такое_потерянное_обновление_lost_update">1.11.1. Что такое потерянное обновление (lost update)?</a></li>
<li><a href="#_способы_защиты_от_потерянных_обновлений">1.11.2. Способы защиты от потерянных обновлений</a></li>
<li><a href="#_защита_от_потерянных_обновлений_в_celesta">1.11.3. Защита от потерянных обновлений в Celesta</a></li>
</ul>
</li>
<li><a href="#Celesta_metadata">1.12. Метаданные Celesta</a>
<ul class="sectlevel3">
<li><a href="#_метаданные_и_их_динамическое_изменение">1.12.1. Метаданные и их динамическое изменение</a></li>
<li><a href="#_состав_метаданных">1.12.2. Состав метаданных</a></li>
<li><a href="#_методы_модификации_метаданных">1.12.3. Методы модификации метаданных</a></li>
</ul>
</li>
<li><a href="#_celestaunit">1.13. CelestaUnit</a>
<ul class="sectlevel3">
<li><a href="#_пример_пользования">1.13.1. Пример пользования</a></li>
<li><a href="#_изменение_настроек_celestaunit_по_умолчанию">1.13.2. Изменение настроек CelestaUnit по умолчанию</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_celesta_и_базы_данных">2. Celesta и Базы данных</a>
<ul class="sectlevel2">
<li><a href="#RDBMS_peculiarities">2.1. Особенности работы Celesta с поддерживаемыми типами СУБД</a>
<ul class="sectlevel3">
<li><a href="#_ms_sql_server">2.1.1. MS SQL Server</a></li>
<li><a href="#_oracle">2.1.2. Oracle</a></li>
<li><a href="#_postgresql">2.1.3. PostgreSQL</a></li>
<li><a href="#_h2">2.1.4. H2</a></li>
</ul>
</li>
<li><a href="#DBSchema">2.2. Проектирование базы данных Celesta в DBSchema</a>
<ul class="sectlevel3">
<li><a href="#_синхронизация_метаданных_celesta_и_проекта_dbschema">2.2.1. Синхронизация метаданных Celesta и проекта DBSchema</a></li>
<li><a href="#_создание_celestasql_скриптов_на_основе_структуры_существующей_бд">2.2.2. Создание CelestaSQL-скриптов на основе структуры существующей БД</a></li>
<li><a href="#_выгрузка_в_plantuml">2.2.3. Выгрузка в PlantUML</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_справочник_celesta">1. Справочник Celesta</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_введение_и_основные_понятия">1.1. Введение и основные понятия</h3>
<div class="sect3">
<h4 id="_введение">1.1.1. Введение</h4>
<div class="sect4">
<h5 id="_описание_и_функциональные_возможности">Описание и функциональные возможности</h5>
<div class="paragraph">
<p>Система Celesta упрощает работу с реляционной базой данных из сервисов, реализующих бизнес-логику, и предоставляет следующее:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Независимость от типа базы данных. Решение, сделанное в Celesta, можно прозрачно переносить между любыми базами данных поддерживаемых типов.</p>
</li>
<li>
<p>Database-first проектирование структуры базы данных либо интеграцию с уже сложившейся базой данных.</p>
</li>
<li>
<p>Автоматически генерируемый на основе структуры БД промежуточный слой доступа к таблицам для написания бизнес-логики.</p>
</li>
<li>
<p>Автоматическую миграцию структуры базы данных на основе <a href="https://dzone.com/articles/trouble-free-database-migration-idempotence-and-co">идемпонтентного DDL</a>.</p>
</li>
<li>
<p>Элементарное модульное тестирование сервисов, работающих с базой данных.</p>
</li>
<li>
<p>Распределение прав доступа к таблицам.</p>
</li>
<li>
<p>При необходимости — аудит изменений, производимых в таблицах.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Система настолько, насколько это возможно прозрачно для разработчиков решения поддерживает следующие типы СУБД (в перспективе данный список может расширяться):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MS SQL Server</p>
</li>
<li>
<p>Oracle</p>
</li>
<li>
<p>Postgre SQL</p>
</li>
<li>
<p>H2</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="celesta_vocabulary">1.1.2. Основные понятия</h4>
<div class="imageblock">
<div class="content">
<img src="images/640px-Duke2-2.png" alt="640px Duke2 2" width="300">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Партитура (Score)</dt>
<dd>
<p>совокупность гранул, с которыми работает данный экземпляр Celesta.</p>
</dd>
<dt class="hdlist1">Гранула (Grain)</dt>
<dd>
<p>функциональная гранула (схема) БД.</p>
</dd>
<dt class="hdlist1">Имя гранулы (Grain name)</dt>
<dd>
<p>уникальный (для всех решений, когда-либо созданных на Celesta) набор латинских букв и цифр, начинающийся с буквы. Рекомендовано использование только строчных букв. Служит для идентификации гранул и разделения таблиц на пространства имён. Примеры имён: <code>bc</code>, <code>skk</code>, <code>sor</code>, <code>skp</code>. Используется, во-первых, для создания пространства имён таблиц (например, через schema в SQL Server), а во-вторых, для создания пакетов, в которых находятся классы слоя доступа к данным. Таким образом, не существует ограничения на глобальную уникальность имени таблицы среди всех гранул — достаточно уникальности имени таблицы внутри гранулы, т. е. могут одновременно существовать, например, таблицы <code>skk.application</code> и <code>sor.application</code>. Имя гранулы должно быть, по возможности, кратким: во-первых, из-за того, что имя каждой гранулы часто используется в коде, а во-вторых, из-за ограничений реализации в СУБД Oracle, суммарная длина имени гранулы и имени таблицы не может превышать 29 символов.</p>
</dd>
<dt class="hdlist1">Скрипт создания гранулы (Grain creation script)</dt>
<dd>
<p>текстовый файл, содержащий скрипт на языке <a href="#CelestaSQL">Язык CelestaSQL</a>. Возможна разработка и модификация скрипта гранулы <a href="#DBSchema">с помощью программы DbSchema</a>. Этот файл содержит информацию о</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>таблицах, включая информацию о</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>полях и их типах (подмножество допустимых типов выбрано таким образом, чтобы обеспечить универсальную поддержку во всех поддерживаемых типах баз данных)</p>
</li>
<li>
<p>первичном ключе (primary key) таблицы – его наличие обязательно требуется для работы промежуточного слоя,</p>
</li>
<li>
<p>DEFAULT-значениях на полях,</p>
</li>
<li>
<p>ограничениях NOT NULL на полях,</p>
</li>
</ol>
</div>
</li>
<li>
<p>индексах,</p>
</li>
<li>
<p>последовательностях (SEQUENCEs),</p>
</li>
<li>
<p>связях между таблицами (Foreign Keys),</p>
</li>
<li>
<p>представлениях (VIEWs).</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Версия гранулы (Grain version tag)</dt>
<dd>
<p>идентификатор версии в виде перечисленных через запятую компонент, явно проставляемый разработчиком гранулы в команде <code>CREATE GRAIN &#8230;&#8203; VERSION &#8230;&#8203;</code> скрипта гранулы. Служит для защиты от непроизвольного автоматического даунгрейда базы данных при запуске старой версии гранулы на более свежей версии базы данных. Автообновление базы данных никогда не будет выполняться, если version tag в базе данных больше, чем version tag скрипта гранулы, либо если версии не согласованы.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Важно</div>
</td>
<td class="content">
Версия состоит из перечисленных через запятую компонент и может выглядеть таким образом: <code>1.23,TITAN3.34</code>. Читать это нужно следующим образом: базовая версия 1.23, доработка для проекта TITAN – 3.34. Регулярное выражение для проверки формата компонента: <code>([A-Z_]*)([0-9]+\\.[0-9]+)</code>. Требуется, чтобы каждая из составляющих версии имела двухкомпонентный (и только  двухкомпонентный!) формат, а префикс либо отсутствовал, либо состоял из заглавных латинских букв и знака подчёркивания. Когда  система определяет возможность автоапгрейда, сравниваются все тэги версии последовательно.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>В этом смысле, по отношению к тэгу «1.23,TITAN3.34»:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>«1.23,TITAN3.35» – более свежая версия (обновилась модификация), можно выполнять автоапгрейд</p>
</li>
<li>
<p>«1.24,TITAN3.34» – более свежая версия (обновилась базовая версия), можно выполнять автоапгрейд</p>
</li>
<li>
<p>«1.23,TITAN3.34,PLUTO1.00» – более свежая версия (добавилась ещё одна модификация), можно выполнять автоапгрейд</p>
</li>
<li>
<p>«TITAN3.34,1.23» – та же самая версия (порядок следования тэгов не играет роли), автоапгрейд выполняться будет лишь при несовпадении контрольных сумм, ошибки не произойдёт</p>
</li>
<li>
<p>«1.22,TITAN3.34» – более старая базовая версия, автоапгрейд выполняться не будет, произойдёт ошибка и Celesta остановится.</p>
</li>
<li>
<p>«1.22,TITAN3.36» – несогласующаяся версия, апдейт выполняться не будет, ошибка. Версии «1.23,PLUTO1.00», «1.25» также будут несогласующимся с версией «1.23,TITAN3.34» и не станут накатываться автоматически (для самоконтроля попробуйте объяснить себе, почему).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Каждая из версий сравнивается, как число с плавающей запятой.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Контрольная сумма гранулы (Grain checksum)</dt>
<dd>
<p>автоматически вычисляемая контрольная сумма скрипта гранулы. Служит для различения гранул по структуре базы данных. Следует осознавать, что скрипты создания гранул, имеющие одинаковый version tag, могут преднамеренно (в процессе разработки) или непреднамеренно (из-за неаккуратности разработчика) иметь различное содержание. База данных, автоматически сформированная по grain creation script, помимо version tag, хранит и контрольную сумму grain creation script&#8217;а, чтобы отследить момент, когда к ней установило контакт приложение с изменённым метаописанием гранулы. Одновременное равенство version tag и grain checksum является достаточным условием для того, чтобы продолжать работу без попыток обновления структуры базы данных.  Ради лёгкости проверки и открытости алгоритма контрольная сумма состоит из двух значений: длины файла скрипта (записываемой в формате десятичного числа) и его CRC32 (записываемом в виде 8 шестнадцатеричных цифр).</p>
</dd>
<dt class="hdlist1">Score path</dt>
<dd>
<p>аналог CLASSPATH для Java, т. е. набор перечисленных через разделитель папок с наборами гранул. Папка с набором гранул — это папка, подпапки которой имеют имена гранул, и содержат скрипты создания гранул с расширением .sql.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Гранулы из папок с наборами для Celesta собираются в единый список, т. е. в процессе работы Celesta нет никакой возможности (и необходимости) определить, к какому из наборов принадлежит та или иная гранула. Каждая гранула в системе должна иметь уникальное имя, и если мы работаем всего с одним набором гранул, то уникальность имени обеспечивается файловой системой. Однако используя несколько наборов гранул через точку с запятой, мы не застрахованы от случая, когда гранула с одним и тем же именем через разные наборы входит в систему дважды. В этом случае при инициализации Celesta произойдёт ошибка. Score path задаётся в настроечном .properties-файле, см. раздел <a href="#basic_settings_section">Базовая настройка Celesta</a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Системная гранула celesta</dt>
<dd>
<p>особая гранула, структура таблиц которой не подлежит изменению. Таблицы этой гранулы используются системой во внутренних целях. При этом запись и редактирование данных в части из этих таблиц является частью стандартной настройки системы. Описание гранулы "celesta" см. в разделе <a href="#system_tables">Системные таблицы Celesta</a>.</p>
</dd>
<dt class="hdlist1">Таблица celesta.grains</dt>
<dd>
<p>системная таблица Celesta в базе данных. Наличие данной таблицы указывает на то, что Celesta подсоединена к «своей» базе данных, в противном случае Celesta будет пытаться развернуть базу «с нуля». Таблица содержит информацию о состоянии гранул, развёрнутых в базе. Описание полей таблицы содержится в разделе <a href="#celesta_grains_table">«Системные таблицы Celesta»</a>. Информация в этой таблице активно используется во время Grain startup sequence (см. далее).</p>
</dd>
<dt class="hdlist1">Статус гранулы в базе данных (Grain database state)</dt>
<dd>
<p>сохраняемое таблице grains состояние гранулы по отношению к базе, наполненной данными. Может быть одним из следующих:</p>
<div class="ulist">
<ul>
<li>
<p>0 – <strong>ready</strong> — гранула развёрнута и готова к использованию (при этом её version tag и контрольная сумма записаны в соответствующих полях таблицы grains).</p>
</li>
<li>
<p>1 – <strong>upgrading</strong> — гранула находится в процессе создания или апгрейда другим приложением Celesta, подключённым к базе данных.</p>
</li>
<li>
<p>2 – <strong>error</strong> — последняя попытка автообновления завершилась неудачно, в этом случае в поле message находится сообщение об ошибке</p>
</li>
<li>
<p>3 – <strong>recover</strong> (эквивалент — отсутствие записи в таблице grains при наличии гранулы в папке score) — гранула отсутствует или нуждается в регенерации (например, после ошибки апгрейда)</p>
</li>
<li>
<p>4 – <strong>lock</strong> — гранула не нуждается в автоматическом обновлении структуры ни при каких обстоятельствах.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Необходимость статуса upgrading определяется тем, что СУБД Oracle не поддерживает DDL-транзакций. В то же время, мы предполагаем возможность одновременного подключения нескольких серверов приложений Celesta к одной базе данных. Выставление статуса upgrading, поэтому, влияет на grain startup sequence и предотвращает конфликты при автоматическом обновлении.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Последовательность запуска гранулы (Grain startup sequence)</dt>
<dd>
<p>операции, выполняемые системой Celesta для каждой гранулы при запуске. При этом, при необходимости, происходит перегенерация классов доступа к данным, а также, при необходимости и возможности, автоапгрейд базы данных (см. далее отдельно про автоапгрейд и activity-диаграммы).</p>
</dd>
<dt class="hdlist1">Автоапгрейд базы данных</dt>
<dd>
<p>составная часть Grain startup sequence, при которой происходит сравнение структуры существующей базы данных со структурой, заданной метаданными в Celesta при помощи скриптов создания гранул. После сравнения разница устраняется с помощью автоматически создаваемых и исполняемых CLREATE/ALTER команд.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_запуск_celesta_и_авто_обновление_бд">1.2. Запуск Celesta и авто-обновление БД</h3>
<div class="sect3">
<h4 id="_инициализация_celesta">1.2.1. Инициализация Celesta</h4>
<div class="paragraph">
<p>Инициализация Celesta происходит в несколько этапов, о чём сообщает вывод в <code>stdout</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Celesta initialization: score parsing...done.
Celesta pre-initialization: system settings reading...done.
Celesta initialization: database upgrade...done.</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>В процессе <strong>чтения системных настроек</strong> Celesta анализирует состояние <a href="#basic_settings_section">базовой настройки</a>, проверяет тот факт, что все обязательные параметры заданы, и что все параметры заданы корректно. При обнаружении ошибки в настройках запуск системы не будет продолжен.</p>
</li>
<li>
<p>При <strong>разборе метаданных</strong> происходит чтение всех файлов *.sql в алфавитном порядке, их синтаксический анализ и построение внутренней объектной модели базы данных (метаданных). Система в папках <code>score</code> собирает из скриптов CelestaSQL информацию о гранулах, таблицах и полях. Вычисляются их контрольные суммы, находятся версии. При возникновении ошибок синтаксиса или несогласованности CelestaSQL-скриптов на данном этапе запуск системы прерывается.</p>
</li>
<li>
<p>Процедура <strong>авто-миграции</strong> базы данных является наиболее сложной и затратной по времени.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_автоматическая_миграция_структуры_данных">1.2.2. Автоматическая миграция структуры данных</h4>
<div class="paragraph">
<p>На этом этапе сервер приложений соединяется с базой данных и проверяет наличие в ней системной таблицы celesta.grains. Если таблица не найдена, она автоматически создаётся (CREATE-командой), однако это происходит лишь в следующих случаях: 1) база данных совершенно пустая 2) в базовой настройке выставлено свойство force.dbinitialize (это защищает от «порчи» существующих, непустых баз данных при ошибочном присоединении к ним системы Celesta). Если в процессе проверки наличия/создания таблицы celesta.grains возникла ошибка, то генерируется фатальная ошибка и система не запускается.</p>
</div>
<div class="paragraph">
<p>Далее идёт цикл по всем доступным в метаданных гранулам и всем доступным в celesta.grains гранулам. (При этом из процесса миграции исключаются гранулы, объявленные с опцией WITH NO AUTOUPDATE в CelestaSQL-скрипте).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Если гранула есть в метаданных, но её нет в celesta.grains — выполняется апдейт по creation-скрипту (т. е. предполагается, что таблицы могут и быть).</p>
</li>
<li>
<p>Если гранула есть в celesta.grains, но её нет в метаданных — ничего не происходит. Автоматически гранулы из базы данных не удаляются, т. к. их таблицы могут содержать важную информацию. Просто в дальнейшем эти таблицы будут недоступны скриптам бизнес-логики Celesta.</p>
</li>
<li>
<p>Если гранула есть и там, и там: сервер приложений находит в таблице celesta.grains запись про состояние, версию и контрольную сумму метаданных, которые «накатаны» на базу данных при последнем запуске и сравнивает с версией метаданных, которыми сервер располагает.</p>
<div class="ulist">
<ul>
<li>
<p><strong>recover (3)</strong> — действуем аналогично отсутствию записи.</p>
</li>
<li>
<p><strong>lock (4)</strong> — структура не обновляется, переходим к следующей грануле.</p>
</li>
<li>
<p><strong>upgrading (1)</strong> — останов процесса с ошибкой  “Cannot proceed with database upgrade: there are grains not in 'ready', 'recover' or 'lock' state”.</p>
</li>
<li>
<p><strong>error (2)</strong> — останов процесса с ошибкой “Cannot proceed with database upgrade: there are grains not in 'ready', 'recover' or 'lock' state”.</p>
</li>
<li>
<p><strong>ready (0)</strong> — продолжение процесса.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Если версия и контрольная сумма совпадают — ничего не происходит.</p>
</li>
<li>
<p>Если версия различна: если версия изменилась в сторону увеличения — апгрейд вне зависимости от контрольной суммы. Если в сторону уменьшения либо если версия несовместима (см. выше описание логики работы с version tags) — вне зависимости от контрольной суммы останов с ошибкой: “Grain '&#8230;&#8203;' version '&#8230;&#8203;' is lower than / is inconsistent with database grain version '&#8230;&#8203;'. Will not proceed with auto-upgrade.”</p>
</li>
<li>
<p>Если версия совпадает, а контрольная сумма различна – апгрейд.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Процедура апгрейда гранулы</strong>. Если на основании описанного выше алгоритма система решает, что апгрейд гранулы необходим — в грануле сбрасываются все представления и начинается цикл по таблицам в метаданных. Если таблица не найдена в базе, она создаётся. Если таблица найдена — цикл по полям. Если поле не найдено, оно создаётся (следует учесть, что добавление в непустую таблицу not null поля без значения default приводит к ошибке). Если поле найдено, и в нём не совпадает тип, default-значение или ограничение null/not null — конвертируется тип или соответствующие атрибуты поля — опять же, это возможно не всегда, в зависимости от имеющихся в таблице данных. Ошибки на данном этапе приводят к переводу гранулы в состояние <strong>error</strong> и требуют ручного вмешательства администратора базы данных. После завершения синхронизации таблиц синхронизируются внешние ключи на таблицах, и полностью синхронизируются индексы на таблицах гранулы, чтобы состав индексов в БД соответствовал составу индексов, объявленных в creation-скрипте. В самую последнюю очередь создаются представления (views).</p>
</div>
<div class="paragraph">
<p>При процедуре апгрейда не происходит удаления полей из базы данных, удаления таблиц и тем более удаления целых гранул. Если администратор базы данных уверен, что соответствующие объекты (и содержащиеся в них данные!) более не нужны, он должен проделать удаление вручную.</p>
</div>
<div class="paragraph">
<p>Тем не менее, при синхронизации будет происходить удаление внешних ключей и индексов, если их объявления были убраны из скрипта создания гранулы.</p>
</div>
<div class="paragraph">
<p>В Celesta имеется три способа отключить процесс автообновления:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>глобально</strong> — с помощью опции skip.dbupdate в <a href="#basic_settings_section">настроечном .properties-файле</a>.</p>
</li>
<li>
<p><strong>на уровне гранулы</strong> — выставив её статус в <a href="#celesta_grains_table">таблице celesta.grains</a> в 4.</p>
</li>
<li>
<p><strong>на уровне таблицы</strong> — объявив <a href="#celestasql_with_options">опцию WITH NO AUTOUPDATE</a> в скрипте создания таблицы.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="basic_settings_section">1.3. Базовая настройка Celesta</h3>
<div class="paragraph">
<p>К базовым настройкам Celesta относятся общесистемные параметры, такие как параметры подключения к базе данных и путь к партитуре (score path, определение этому термину см. в разделе <a href="#celesta_vocabulary">Основные понятия</a>).</p>
</div>
<div class="paragraph">
<p>Эти настройки выполняются в .properties-файле системы, в которую встроена Celesta.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Внимание</div>
</td>
<td class="content">
TODO сделать примеры для Spring Boot
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Базовыми настройками Celesta являются:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle">Параметр</th>
<th class="tableblock halign-center valign-middle">Назначение</th>
<th class="tableblock halign-center valign-middle">Обязательный</th>
<th class="tableblock halign-center valign-middle">Пример значения</th>
<th class="tableblock halign-center valign-middle">Значение по умолчанию</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">score.path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">score path Celesta (список папок, разделённый разделителем путей, специфичным для операционной системы)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Да</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">c:/eDacha/score/;c:/celestabasic</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pylib.path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">путь к папке со стандартными библиотеками Jython</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Нет</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">c:/Program Files/Apache Software Foundation/Tomcat 7.0/webapps/edacha/WEB-INF/libJython/</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">pylib</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">javalib.path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">список папок с .jar-файлами, разделённый разделителем путей, каждый из которых будет добавлен в classpath при запуске Celesta и, как следствие, будет доступен в jython-скриптах</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Нет</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">c:/pathto/javalib1;c:/pathto/javalib2</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rdbms.connection.url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL подключения к JDBC-драйверу</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Да</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>jdbc:sqlserver://172.16.1.114:52836;databaseName=celesta;user=sa;password=111</p>
</li>
<li>
<p>jdbc:postgresql://127.0.0.1:5432/celesta?user=postgres&amp;password=7464</p>
</li>
<li>
<p>jdbc:oracle:thin:celesta/123@192.168.110.128:1521:XE</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rdbms.connection.username</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Логин для подключения к базе данных</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Нет (если не заполнен, используется информация из rdbms.connection.url)</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rdbms.connection.password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Пароль для подключения к базе данных</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Нет (если не заполнен, используется информация из rdbms.connection.url</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">skip.dbupdate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Заставляет систему при инициализации полностью пропустить фазу обновления базы данных (включая создание системных таблиц).
Этот параметр категорически не рекомендуется включать, если вы не знаете твёрдо, чего хотите добиться.</p>
<p class="tableblock">Этот параметр требуется при некоторых сценариях разворачивания Celesta на заранее существующей базе данных - например, для работы системы Flute, если в её скриптах не планируется использовать классы Celesta для доступа к данным.</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Нет</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">force.dbinitialize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Заставляет систему при инициализации создавать системные объекты Celesta даже в том случае, если база данных не пустая (уже содержит таблицы).
Этот параметр категорически не рекомендуется включать, если вы не знаете твёрдо, чего хотите добиться, и рекомендуется выключать после того, как база данных будет проинициализирована один раз.</p>
<p class="tableblock">Этот параметр требуется при некоторых сценариях разворачивания Celesta на заранее существующей базе данных.</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Нет</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">h2.in-memory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Значение true заставляет Celesta использовать базу H2 в in-memory режиме. Параметры JDBC подключения при этом игнорируются. Режим необходим, прежде всего, для модульных тестов.</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Нет</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">h2.port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Если указано целочисленное значение, и при этом h2.in-memory установлено в true, то база H2 запускается в виде сервера на указанном порту. Данный режим позволяет присоединяться к базе данных H2 внешним приложениям, читать и модифицировать данные. Параметры JDBC подключения при этом игнорируются. Этот режим необходим для UI и приёмочных автоматических тестов.</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Нет</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">h2.referential.integrity</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Использовать ли контроль ссылочной целостности (контроль Foreign Keys), работая с базой H2 в in-memory режиме (для всех других БД данный параметр игнорируется). По умолчанию при работе с H2 in-memory, ссылочная целостность отключается для упрощения создания модульных тестов.</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Нет</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Замечание</strong>: При инициализации celesta в свойство score.path добавляется папка "general/score" с тем, что в ней могут храниться общесистемные гранулы для всех userdat.</p>
</div>
</div>
<div class="sect2">
<h3 id="system_tables">1.4. Системные таблицы Celesta</h3>
<div class="sect3">
<h4 id="_структура_системной_гранулы_celesta">1.4.1. Структура системной гранулы "celesta"</h4>
<div class="paragraph">
<p>Помимо таблиц и гранул, определённых пользователем, система Celesta добавляет в базу данных таблицы в собственной системной грануле "celesta", структура которой представлена на диаграмме ниже.</p>
</div>
<div class="paragraph">
<p>Структура (в том числе состав полей) таблиц, относящихся к системной грануле "celesta", не подлежит изменению, а для доступа к их данным используются встроенные классы из пакета ru.curs.celesta.syscursors. Тем не менее, изменение данных в части из этих таблиц является частью штатной, необходимой настройки системы.</p>
</div>
<div class="paragraph">
<p>Системные таблицы предназначены для:</p>
</div>
<div class="paragraph">
<p>Координирования автоапгрейда (таблица celesta.grains, подробно описанная в данном руководстве).
Распределения прав доступа к таблицам и представлениям.
Настройки системы логирования и хранения логов.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Celestagrain.png" alt="Celestagrain" width="100%">
</div>
</div>
<div class="paragraph">
<p>Назначение таблиц:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">celesta.grains</dt>
<dd>
<p>перечень гранул со статусами. Ведётся автоматически, ручные изменения разработчиком решений сводятся к выставлению статуса "recover" на грануле после неудавшейся попытки автообновления и к удалению записи об удалённой грануле.</p>
</dd>
<dt class="hdlist1">celesta.tables</dt>
<dd>
<p>перечень таблиц и представлений. Содержимое данной таблицы автоматически синхронизируется с перечнем таблиц и представлений, доступных в гранулах Celesta, пользователю не следует вмешиваться в данные этой таблицы (в любом случае изменения будут потеряны при следующей синхронизации). Поле tabletype указывает на то, является запись таблицей ("T") или представлением ("V").</p>
</dd>
<dt class="hdlist1">celesta.roles</dt>
<dd>
<p>перечень ролей celesta. Сюда следует вручную добавлять роли, в том числе роли с системными именами "reader", "editor" и т. д. (о ролях с системными именами см. ниже).</p>
</dd>
<dt class="hdlist1">celesta.userroles</dt>
<dd>
<p>связь идентификаторов пользователей (логинов) с ролями. Заполняется вручную.</p>
</dd>
<dt class="hdlist1">celesta.permissions</dt>
<dd>
<p>разрешения ролям на таблицы. Заполняется вручную.</p>
</dd>
<dt class="hdlist1">celesta.logsetup</dt>
<dd>
<p>настройки логирования. Заполняется вручную.</p>
</dd>
<dt class="hdlist1">celesta.log</dt>
<dd>
<p>лог изменений. Заполняется системой автоматически при каждом изменении данных, однако данные пишутся лишь по таблицам и действиям, указанным в celesta.logsetup.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="celesta_grains_table">1.4.2. Таблица celesta.grains</h4>
<div class="paragraph">
<p>Данная таблица является важнейшей из системных таблиц Celesta, т. к. её содержимое управляет синхронизацией структуры базы данных с метаданными в момент запуска системы. Таблица содержит следующие поля:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Имя поля</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Тип поля</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Значение поля</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">varchar(16)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">имя (код) гранулы</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">version tag гранулы</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">length</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">длина creation-скрипта гранулы в байтах (составляющая часть контрольной суммы)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">checksum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CRC32 creation-скрипта гранулы (составляющая часть контрольной суммы)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>статус гранулы:
* 0 – ready — гранула развёрнута и готова к использованию (при этом её version tag и контрольная сумма записаны в полях version, length, checksum).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1 – upgrading — гранула находится в процессе создания или апгрейда другим приложением Celesta, подключённым к базе данных.</p>
</li>
<li>
<p>2 – error — последняя попытка автообновления завершилась неудачно, в этом случае в поле message находится сообщение об ошибке</p>
</li>
<li>
<p>3 – recover (эквивалент — отсутствие записи в таблице grains при наличии гранулы в папке score) — гранула отсутствует или нуждается в регенерации (например, после ошибки апгрейда)</p>
</li>
<li>
<p>4 – lock — гранула не нуждается в автоматическом обновлении структуры ни при каких обстоятельствах</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lastmodified</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">datetime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">дата и время последнего обновления статуса гранулы</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">комментарий (например, сообщение об ошибке при последнем неудавшемся автообновлении)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_система_распределения_прав_доступа">1.4.3. Система распределения прав доступа.</h4>
<div class="paragraph">
<p>Как видно из структуры таблиц, права на таблицы раздаются ролям, прямой раздачи прав пользователям не предусмотрено.</p>
</div>
<div class="paragraph">
<p>В поле roleid указывается идентификатор роли, в полях grainid и tablename — ссылка на таблицу. В битовых полях r, i, m, d выставляются флаги, если необходимы права, соответственно, на чтение, вставку, модификацию и удаление.</p>
</div>
<div class="paragraph">
<p>Предусмотрены также специальные, системные имена ролей: <strong>reader</strong> и <strong>editor</strong>, а также роли вида <strong>&lt;имя гранулы&gt;.reader</strong> и <strong>&lt;имя гранулы&gt;.editor</strong>.</p>
</div>
<div class="paragraph">
<p>Роль reader даёт право на чтение всех без исключения таблиц, роль &lt;имя гранулы&gt;.reader (например, "skk.reader") даёт право на чтение всех таблиц в соответствующей грануле.</p>
</div>
<div class="paragraph">
<p>Роль editor даёт полные права (на чтение, вставку, модификацию и удаление) всех таблиц. Роль &lt;имя гранулы&gt;.editor (например, "skk.editor") даёт полные права на все таблиц в соответствующей грануле.</p>
</div>
</div>
<div class="sect3">
<h4 id="_система_логирования">1.4.4. Система логирования</h4>
<div class="paragraph">
<p>При любом изменении данных, производимых через курсоры Celesta, работает не только система распределения прав доступа, но также и система логирования изменений данных, записывая все изменения в таблицу <strong>celesta.log</strong>. Однако, чтобы <strong>celesta.log</strong> не засорялась потенциально огромным количеством ненужных данных, логируются лишь изменения на таблицах, явно указанных в таблице <strong>celesta.logsetup</strong>. Более того, имеется возможность отдельно включать логирование вставки, модификации и удаления записи.</p>
</div>
<div class="paragraph">
<p>Для того, чтобы включить логирование изменений данных таблиц, производимых через систему Celesta, необходимо занести соответствующие настройки в таблицу <strong>celesta.logsetup</strong>. При этом в полях grainid и tablename указывается ссылка на таблицу, а в битовых полях i, m, d выставляются флаги, если необходимо логирование, соответственно, вставки, модификации и удаления.</p>
</div>
<div class="paragraph">
<p>Таблица celesta.log состоит из следующих полей:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Имя поля</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Тип поля</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Значение поля</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">entryno</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">автоинкрементируемый целочисленный номер записи в таблице лога</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">entry_time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATETIME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">время записи</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">userid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(250)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">идентификатор пользователя, от имени которого произведено изменение</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sessionid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(250)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">идентификатор пользовательской сессии, в рамках которой произведено изменение</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">grainid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(16)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">идентификатор гранулы</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tablename</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(100)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">имя таблицы</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">action_type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(1)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">тип действия (I для вставки, M для модификации, D для удаления)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pkvalue1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">varchar(100)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">значение первого поля первичного ключа (сведённое к текстовому типу)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pkvalue2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">varchar(100)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">значение второго поля первичного ключа (если есть, сведённое к текстовому типу)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pkvalue3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">varchar(100)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">значение третьего поля первичного ключа (если есть, сведённое к текстовому типу)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">oldvalues</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">varchar(4000)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">прежнее состояние записи (поля сведены к тексту и перечислены через запятую в формате CSV, информация обрезана по длине поля). Значение поля заполняется для действий M и D</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">newvalues</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">varchar(4000)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">текущее состояние записи в том же формате, что и в поле oldvalues. Заполняется для действий M и I</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_система_профилирования">1.4.5. Система профилирования</h4>
<div class="paragraph">
<p>Для поиска и устранения проблем, связанных с быстродействием, Celesta может работать в режиме профилирования, включаемом при помощи метода setProfilemode(true) экземпляра Celesta.</p>
</div>
<div class="paragraph">
<p>В режиме профилирования информация обо всех вызовах процедур записывается в таблицу calllog, состоящую из следующих полей:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Имя поля</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Тип поля</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Значение поля</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">entryno</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">автоинкрементируемый целочисленный номер записи в таблице лога</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sessionid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(250)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">идентификатор пользовательской сессии, в которой была запущена процедура</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">userid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(250)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">идентификатор пользователя, от имени которого работала пользовательская сессия</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">procname</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(250)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">имя выполнявшейся процедуры (трёхкомпонентное имя процедуры Celesta)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">starttime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATETIME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">время начала выполнения процедуры</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">duration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">общее время выполнения процедуры (в миллисекундах)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="CelestaSQL">1.5. Язык CelestaSQL</h3>
<div class="sect3">
<h4 id="_язык_celestasql_определения_объектов_базы_данных">1.5.1. Язык CelestaSQL определения объектов базы данных</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Важно</div>
</td>
<td class="content">
Скрипты на языке CelestaSQL должны иметь кодировку UTF-8 без <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">символа BOM</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>На языке Celesta SQL пишутся скрипты определения гранул. Скрипт на языке CelestaSQL состоит из конструкций</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#create_schema_statement">CREATE GRAIN</a>,</p>
</li>
<li>
<p><a href="#create_sequence_statement">CREATE SEQUENCE</a>,</p>
</li>
<li>
<p><a href="#create_table_statement">CREATE TABLE</a>,</p>
</li>
<li>
<p><a href="#foreign_keys_statements">ALTER TABLE ADD &#8230;&#8203; FOREIGN KEY</a>,</p>
</li>
<li>
<p><a href="#create_index_statement">CREATE INDEX</a>,</p>
</li>
<li>
<p><a href="#create_view_statement">CREATE VIEW</a>,</p>
</li>
<li>
<p><a href="#create_materialized_view_statement">CREATE MATERIALIZED VIEW</a>,</p>
</li>
<li>
<p><a href="#create_function_statement">CREATE FUNCTION</a>,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>в обязательном порядке разделённых точкой с запятой, начиная с <code>CREATE GRAIN</code>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/1.file.png" alt="1.file" width="60%">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_комментарии_в_языке_celestasql">1.5.2. Комментарии в языке CelestaSQL</h4>
<div class="paragraph">
<p>CelestaSQL поддерживает стандартные однострочные и многострочные комментарии, а также комментарии <a href="#_celestadoc">CelestaDoc</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">-- однострочный комментарий
/*многострочный
    комментарий*/
 /**комментарий CelestaDoc*/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обычные комментарии могут использоваться в любом месте текста, комментарии CelestaDoc — только непосредственно перед определением гранулы, таблицы, поля или индекса.</p>
</div>
</div>
<div class="sect3">
<h4 id="_идентификаторы_объектов_в_языке_celestasql">1.5.3. Идентификаторы объектов в языке CelestaSQL</h4>
<div class="paragraph">
<p>Идентификаторы объектов — это, иначе говоря, имена гранул, таблиц, полей, индексов, ограничений и представлений, их синтаксис в Celesta имеет ряд строгих ограничений.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>В обычных СУБД дозволяется, чтобы идентификаторы объектов содержали знаки пробела и неалфавитные знаки, если эти имена заключены в обрамляющие символы, например «[]» для MS SQL Server. Т. е. в MS SQLServer допустимо, например, такое имя таблицы: [Long Table$Name]. Celesta, однако, не может поддерживать пробелы и неалфавитные знаки в идентификаторах потому, что имя каждой Celesta-таблицы должно являться именем Python-класса, а имя каждого Celesta-поля — именем Python-переменной. Поэтому идентификатор любого именованного объекта CelestaSQL должен удовлетворять правилам наименования переменной в Python, т. е. <strong>может состоять только из больших и малых букв латинского алфавита, цифр и знаков подчёркивания, при этом не может начинаться с цифры</strong>.</p>
</li>
<li>
<p><strong>Заключение идентификаторов Celesta в кавычки</strong> в скриптах CelestaSQL <strong>не допускается</strong> на уровне синтаксиса, т. к. практической надобности в этом нет (имена никогда не содержат пробелов). На системном уровне при формировании запросов к СУБД Celesta, однако, всегда заключает имена своих объектов в прямые кавычки ("ANSI quotes"), чтобы гарантировать, что базы данных Oracle, PostgreSQL и H2 не будут нарушать регистр букв, составляющих идентификатор.</p>
</li>
<li>
<p><strong>Идентификаторы</strong> в Celesta <strong>являются чувствительными к регистру</strong>, однако нельзя создавать две таблицы, имена которых отличаются только регистром.</p>
</li>
<li>
<p><strong>Длина</strong> любого идентификатора в Celesta <strong>не может быть больше 30 символов</strong>.</p>
</li>
<li>
<p><strong>Идентификаторы (префиксы) гранул, кроме того, не могут содержать в себе знаков подчёркивания</strong>. Это связано с тем, что комбинация имени гранулы со знаком подчёркивания и другим идентификатором зачастую используется во внутрисистемных целях Celesta, и запрет на использование знака подчёркивания в именах гранул необходим для исключения возможных неоднозначностей.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="create_schema_statement">1.5.4. Конструкция CREATE SCHEMA (GRAIN)</h4>
<div class="paragraph">
<p>С выражения CREATE SCHEMA должен начинаться любой скрипт определения гранулы. Используется следующий синтаксис (слова GRAIN и SCHEMA являются синонимами):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/2.create_grain.png" alt="2.create grain" width="100%">
</div>
</div>
<div class="paragraph">
<p>Опция WIH NO AUTOUPDATE исключает схему целиком из процесса автообновления базы данных. Как и соответствующая <a href="#celestasql_with_options">опция таблицы</a>, может быть использована в ситуации, когда структура схемы находится под внешним управлением.</p>
</div>
</div>
<div class="sect3">
<h4 id="create_sequence_statement">1.5.5. Конструкция CREATE SEQUENCE</h4>
<div class="paragraph">
<p>Используется следующий синтаксис:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/3.create_sequence.png" alt="3.create sequence" width="100%">
</div>
</div>
<div class="paragraph">
<p>Основными ограничениями и отличиями такого запроса от SQL-запросов в различных СУБД являются:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Не поддерживается в версиях MSSQL ниже 2011</p>
</li>
<li>
<p>Если не указано значение MINVALUE, то оно автоматически выставляется равным значению START WITH (по умолчанию 1)</p>
</li>
<li>
<p>Если не указано значение MAXVALUE, то оно автоматически выставляется равным значению Long.MAX_VALUE</p>
</li>
<li>
<p>Значение START WITH не обновляется для созданных ранее последовательностей, даже если было изменено в файле гранулы (связано с тем, что oracle разрешает данную операцию только через удаление и пересоздание последовательности, а идеология celesta не предусматривает удаление statefull объектов из БД)</p>
</li>
<li>
<p>Если в грануле присутствует таблица с именем, например, A, то является недопустимым создание последовательности с именем A_seq, так как это имя зарезервировано системой</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="create_table_statement">1.5.6. Конструкция CREATE TABLE</h4>
<div class="paragraph">
<p>Используется следующий синтаксис:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/3.create_table.png" alt="3.create table" width="100%">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/4.table_constituent.png" alt="4.table constituent" width="70%">
</div>
</div>
<div class="paragraph">
<p>Иными словами, в конструкции CREATE TABLE в скобках через запятую в любом порядке могут быть перечислены определения полей, определения первичных ключей или определения внешних ключей, а за скобками, возможно, перечислены опции. На практике определения всех полей идут подряд в самом начале, далее — определения составных первичных ключей (первичные ключи, состоящие из одного поля, можно определять на самом поле) и определения составных внешний ключей (опять же, внешние ключи, состоящие из одного поля, можно определять на самом поле).</p>
</div>
<div class="sect4">
<h5 id="_определения_полей">Определения полей</h5>
<div class="imageblock">
<div class="content">
<img src="images/4.field_definition.png" alt="4.field definition" width="100%">
</div>
</div>
<div class="paragraph">
<p><strong>field_definition</strong> (Определение поля) — конструкция, задающая тип поля, название поля, его свойства NULL/NOT NULL и DEFAULT, опционально может заканчиваться конструкцией PRIMARY KEY и/или FOREIGN KEY.</p>
</div>
<div class="paragraph">
<p>Сокращенное определение внешнего ключа (<strong>inline_fk_definition</strong>) имеет следующий синтаксис:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/5.inline_fk_definition.png" alt="5.inline fk definition" width="100%">
</div>
</div>
<div class="paragraph">
<p>Здесь <strong>table_ref</strong> — ссылка на таблицу, которая может быть однокомпонентной (если таблица, на которую указывает внешний ключ, находится в текущей грануле) или двухкомпонентной, с явным указанием имени гранулы:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/6.table_ref.png" alt="6.table ref" width="60%">
</div>
</div>
<div class="paragraph">
<p>Определение синтаксиса правил внешних ключей (<strong>fk_rules</strong>) см. в разделе <a href="#foreign_keys_statements">Внешние ключи»</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_типы_данных">Типы данных</h5>
<div class="paragraph">
<p>Используется следующая система типов данных.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">CELESTA</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Microsoft SQL Server</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Oracle</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">PostgreSQL</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">H2</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Java Type For Cursor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nteger (32-bit)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NUMBER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang.Integer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Floating point (64-bit)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">REAL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FLOAT(53)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">REAL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FLOAT8
[= DOUBLE PRECISION]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ava.lang.Double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixed point (decimal)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DECIMAL(p,s)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DECIMAL(p,s)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NUMBER(p,s)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NUMERIC(p,s)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DECIMAL(p,s)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.math.BigDecimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String (Unicode)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NVARCHAR(n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NVARCHAR(n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang.String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long string (Unicode)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TEXT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NVARCHAR(MAX)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NCLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TEXT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang.String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARBINARY(MAX)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BYTEA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARBINARY(MAX)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang.String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date/Time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATETIME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATETIME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util.Date</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DateTime With Time Zone</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATETIME WITH TIME ZONE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATETIMEOFFSET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP WITH TIME ZONE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMPZ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP WITH TIME ZONE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.ZonedDateTime</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NUMBER
[check in (0, 1)]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang.Boolean</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>См. также раздел «<a href="#RDBMS_peculiarities">Особенности работы Celesta с поддерживаемыми типами СУБД</a>».</p>
</div>
<div class="paragraph">
<p>Для каждого типа поля имеется свой вариант определения:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/8.int_field.png" alt="8.int field" width="100%">
</div>
</div>
<div class="paragraph">
<p>Вместо конструкции DEFAULT &lt;целое число&gt; для поля с типом INT может использоваться конструкция NEXTVAL(&lt;sequence name&gt;). Таким образом значение колонки будет инкрементироваться при вставке в зависимости от указанной последовательности. Стоит отметить, что можно использовать только последовательности, объявленные в той же грануле, что и таблица, к которой принадлежит колонка.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/9.floating_field.png" alt="9.floating field" width="90%">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/795px-13.decimal_field.png" alt="795px 13.decimal field" width="100%">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/10.text_field.png" alt="10.text field" width="100%">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/11.blob_field.png" alt="11.blob field" width="90%">
</div>
</div>
<div class="paragraph">
<p>Здесь <strong>&lt;binary literal&gt;</strong> — шестнадцатеричное представление последовательности байтов, начинающееся с 0x и не заключённые в кавычки, например: 0xFFAAFFAAFF.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/12.datetime_field.png" alt="12.datetime field" width="100%">
</div>
</div>
<div class="paragraph">
<p>В качестве значения DEFAULT для поля с типом DATETIME может использоваться функция GETDATE() (текущий момент времени).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/17.datetime_with_time_zone_field.png" alt="17.datetime with time zone field" width="70%">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/13.bit_field.png" alt="13.bit field" width="80%">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_первичные_ключи">Первичные ключи</h5>
<div class="imageblock">
<div class="content">
<img src="images/14.primary_key_definition.png" alt="14.primary key definition" width="60%">
</div>
</div>
<div class="paragraph">
<p><strong>primary_key_definition</strong> (определение первичного ключа) — конструкция, задающая состав полей, входящих в первичный ключ таблицы. Возможно в двух вариантах:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>сокращённый вариант — когда ключевые слова “PRIMARY KEY” идут сразу после определения поля, это даёт возможность более короткой и наглядной записи в случае, когда первичный ключ состоит всего из одного поля</p>
</li>
<li>
<p>полный вариант — когда конструкция PRIMARY KEY находится в определении таблицы среди определения полей, и может содержать как одно поле, так и любое количество полей.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ограничения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Самое важное: для обеспечения работоспособности системы не допускается создание таблиц без PRIMARY KEY</strong>. (За исключением READ ONLY-таблиц).</p>
</li>
<li>
<p>В таблице может быть не более одного упоминания PRIMARY KEY, будь то сокращённое выражение в конце определения поля или составное выражение в определении таблицы.</p>
</li>
<li>
<p>Не допускается создание PK по полям с типами BLOB и TEXT.</p>
</li>
<li>
<p>Не допускается создание PK по nullable-полям.</p>
</li>
<li>
<p>Не допускается более одного вхождения одного и того же поля в определение PRIMARY KEY.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="foreign_keys_statements">Внешние ключи</h5>
<div class="imageblock">
<div class="content">
<img src="images/15.foreign_key_definition.png" alt="15.foreign key definition" width="100%">
</div>
</div>
<div class="paragraph">
<p><strong>foreign_key_definition</strong> (Определение внешнего ключа) — конструкция, задающая связь между таблицами по одному или нескольким полям. Как и в случае с конструкцией PRIMARY KEY, возможно использование в двух вариантах — сокращённом (встроенном в определение поля, связь по одному полю) и полном (перечисляется среди определений полей). Кроме того, внешний ключ можно создать вне определения таблицы при помощи конструкции "alter table add constraint foreign key":</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/16.add_foreign_key.png" alt="16.add foreign key" width="100%">
</div>
</div>
<div class="paragraph">
<p>Ограничения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Foreign key, простой или составной, может ссылаться только на Primary Key, причём полностью. (В Celesta SQL не допускаются ограничения UNIQUE, поэтому из двух возможностей, стандартно предлагаемых в СУБД для Foreign Keys, остаётся только возможность ссылки на Primary Key).</p>
</li>
<li>
<p>Типы полей должны в точности совпадать (если поле – строковое, длина ссылающегося поля должна быть точно равна длине поля, на которое ссылаются).</p>
</li>
<li>
<p>Нельзя создать более одного определения Foreign Key на одном и том же наборе столбцов (частный случай – не может быть двух FK, определённых для одного и того же столбца).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>fk_rules</strong> — ссылочные действия:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/7.fk_rules.png" alt="7.fk rules" width="100%">
</div>
</div>
<div class="paragraph">
<p>Поддерживаемые ссылочные действия:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NO ACTION – запрет удаления/модификации родительской записи, если на неё есть ссылки</p>
</li>
<li>
<p>SET NULL – выставление NULL в ссылках. Внимание: естественно, использовать это действие запрещено для NOT NULL-able полей</p>
</li>
<li>
<p>CASCADE – каскадное удаление/обновление полей.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В момент создания foreign key сослаться можно только</p>
</div>
<div class="ulist">
<ul>
<li>
<p>на таблицу, определённую в текущей грануле выше по тексту</p>
</li>
<li>
<p>на таблицу, определённую с другой грануле.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Внимание</div>
</td>
<td class="content">
«Зацикленные» ссылки по foreign key (например, вида A&#8594;B&#8594;C&#8594;A) при разработке структуры базы данных в действительности нужны крайне редко и обычно говорят об ошибке проектировщика. Единственный широко применимый практически значимый пример «зацикливания» — ссылка таблицы на саму себя при организации иерархического перечня по принципу parent-child.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>В Celesta не допускается создание «зацикленных» ссылок между таблицами, принадлежащими разным гранулам. Если надо организовать ссылки по кругу между несколькими таблицами внутри гранулы, то это можно сделать, воспользовавшись конструкцией "alter table add constraint foreign key".</p>
</div>
<div class="paragraph">
<p>В частности, работает следующий пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE aa(idaa INT NOT NULL PRIMARY KEY, idc INT , textvalue nvarchar(10));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE a (ida INT NOT NULL PRIMARY KEY, descr nvarchar(2), parent INT
                FOREIGN KEY REFERENCES a(ida), --ссылка таблицы на саму себя
                fff INT FOREIGN KEY REFERENCES aa(idaa) --первая часть круговой ссылки</code></pre>
</div>
</div>
<div class="paragraph">
<p>внешний ключ, создаваемый вне таблицы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">ALTER TABLE aa ADD CONSTRAINT fk1
FOREIGN KEY (idc) REFERENCES a(ida); --вторая часть круговой ссылки
&lt;/syntaxhighlight&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пример создания составного ключа, состоящего из двух полей:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">&lt;syntaxhighlight lang ="sql"&gt;
CREATE TABLE empfiles(
  id INT NOT NULL PRIMARY KEY,
  user_id varchar(200) NOT NULL,
  orgtype_id varchar(255) NOT NULL,
  question_id varchar(30) NOT NULL,
  FOREIGN KEY (orgtype_id, question_id) REFERENCES schema.table(field, field)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="celestasql_with_options">Опции</h5>
<div class="paragraph">
<p>Celesta позволяет указывать следующие опции после определения таблицы:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/5.table_options.png" alt="5.table options" width="100%">
</div>
</div>
<div class="paragraph">
<p>Таким образом, поддерживаются следующие возможности:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WITH VERSION CHECK — режим по умолчанию: включение механизма отслеживания версий записей для исключения потерянных обновлений (см. раздел Защита от потерянных обновлений). Указывать данную опцию явно не требуется.</p>
</li>
<li>
<p>WITH NO VERSION CHECK — отключение механизма отслеживания версий записей. Требуется в случаях, когда нет желания вводить новое системное поле в таблицу. Возможность модифицировать данные в таблице при этом сохраняется, но возможны «потерянные обновления».</p>
</li>
<li>
<p>WITH READ ONLY — режим «только чтение». Требуется в случаях, когда данные таблицы поступают из внешних источников, а не заносятся средствами Celesta, либо если необходимо подключиться к таблице, относящейся к иному приложению, и потому нежелательно вносить в её структуру какие-либо изменения. В этом режиме механизм отслеживания версий записей отключается, а ORM-класс для доступа к таблице генерируется без методов модификации данных. Кроме того, для таких таблиц не требуется указывать первичный ключ.</p>
</li>
<li>
<p>Опция NO AUTOUPDATE, которая может применяться совместно с данными опциями, отключает таблицу от процесса автообновления базы данных. Используется в случае, когда структура какой-либо таблицы изменяется в базе данных вручную и система не должна пытаться синхронизировать структуру этой таблицы с описанием на языке CelestaSQL автоматически.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="create_index_statement">1.5.7. Конструкция CREATE INDEX</h4>
<div class="paragraph">
<p>Индексы применяются для ускорения фильтрации по полям таблиц и создаются при помощи следующей синтаксической конструкции:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/17.create_index.png" alt="17.create index" width="100%">
</div>
</div>
<div class="paragraph">
<p>Имена индексов должны быть уникальны в пределах гранулы. Все индексы в Celesta допускают неуникальные значения.</p>
</div>
</div>
<div class="sect3">
<h4 id="create_view_statement">1.5.8. Конструкция CREATE VIEW</h4>
<div class="paragraph">
<p>Представления (views) служат для доступа только на чтение к данным, собранным из одной или нескольких таблиц при помощи SQL-запроса SELECT. Для каждого своего представления Celesta создаёт объект-представление в базе данных, транслируя при этом SQL-запрос на языке CelestaSQL в соответствующий диалект языка SQL.</p>
</div>
<div class="paragraph">
<p>Представления создаются при помощи синтаксической конструкции</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/18.create_view.png" alt="18.create view" width="70%">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>&lt;view name&gt;</strong> (имя представления) должно быть уникальным в пределах гранулы и не совпадать с именем таблицы.</p>
</li>
<li>
<p><strong>query</strong> (запрос) представляет собой SQL-запрос, имеющий следующий синтаксис:</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/800px-19.query.png" alt="800px 19.query" width="100%">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/800px-20.from_clause.png" alt="800px 20.from clause" width="100%">
</div>
</div>
<div class="paragraph">
<p>Основными ограничениями и отличиями такого запроса от SQL-запросов в различных СУБД являются:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Запросы строятся только на таблицах (текущей гранулы или соседних гранул). Во избежание выстраивания неэффективных конструкций невозможно построение запросов на представлениях.</p>
</li>
<li>
<p>Конструкция SELECT * не поддерживается, и всякое поле запроса, если только это не ссылка на поле таблицы с уникальным в рамках запроса именем, должно иметь определённый и уникальный псевдоним. Это нужно для возможности однозначного создания класса-курсора, поля которого соответствуют именам столбцов запроса.</p>
</li>
<li>
<p>Не поддерживается конструкция ORDER BY, т. к. при необходимости определённым образом отсортировать результирующий набор следует воспользоваться методом orderBy(&#8230;&#8203;) соответствующего курсора.</p>
</li>
<li>
<p>Не поддерживается конструкция GROUP BY&#8230;&#8203;HAVING (разработка поддержки этой конструкции возможна лишь при возникновении обоснованной необходимости в данной функциональности).</p>
</li>
<li>
<p>Не поддерживаются FULL JOIN (объединения LEFT и RIGHT joins) и CROSS JOIN (декартовы произведения таблиц). Практическая значимость FULL JOIN сомнительна. CROSS JOIN сам по себе также не бывает практически необходим, неосторожное использование может привести к проблемам производительности.</p>
</li>
<li>
<p>Не поддерживаются конструкции UNION, WITH, любые вложенные запросы. Конструкция бизнес-приложения должна предусматривать достаточное количество таблиц с данными, чтобы в этих конструкциях не было необходимости.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ссылка на таблицу (<strong>table_ref</strong>) имеет синтаксис</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/6.table_ref_1.png" alt="6.table ref 1" width="60%">
</div>
</div>
<div class="paragraph">
<p>Имя гранулы указывать не обязательно, если таблица находится в той же грануле, что и текущее представление.</p>
</div>
<div class="paragraph">
<p>Терм, определяющий поле представления, имеет следующий синтаксис:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/21.term.png" alt="21.term" width="60%">
</div>
</div>
<div class="paragraph">
<p>Над выражениям типа INTEGER и REAL допустимы обычные арифметические операции с обычным приоритетом: максимальный приоритет у унарного минуса, далее — умножение и деление («*», «/»), далее — сложение и вычитание («+», «-»). Над выражениями типа NVARCHAR допустима операция конкатенации «||». Операции над полями прочих типов недопустимы.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/22.primary_term.png" alt="22.primary term" width="70%">
</div>
</div>
<div class="paragraph">
<p>Ссылки на поля могут быть однокомпонентными (если они однозначно указывают на поле определённой таблицы) либо двухкомпонентными, в этом случае в качестве первой компоненты следует указывать псевдоним таблицы из конструкции FROM либо — если явный псевдоним отсутствует — имя таблицы.</p>
</div>
<div class="paragraph">
<p>Наконец, синтаксис логического выражения <strong>condition</strong>, используемого в конструкциях JOIN &#8230;&#8203; ON и WHERE:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/23.condition.png" alt="23.condition" width="70%">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/24.predicate.png" alt="24.predicate" width="60%">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/25.aggregate.png" alt="25.aggregate" width="80%">
</div>
</div>
<div class="paragraph">
<p>Стоит отметить, что term внутри конструкции SUM должен являться числом.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/26.group_by.png" alt="26.group by" width="60%">
</div>
</div>
<div class="paragraph">
<p>Особенность конструкции GROUP BY в Celesta-SQL заключается в необходимости всегда перечислять в ней все неагрегатные колоноки из выборки.</p>
</div>
</div>
<div class="sect3">
<h4 id="create_materialized_view_statement">1.5.9. Конструкция CREATE MATERIALIZED VIEW</h4>
<div class="paragraph">
<p>Материализованные представления (materialized views) служат для доступа только на чтение к агрегатным данным, собранным из одной таблицы и объединенным при помощи выражения GROUP BY. Для каждого своего материализованного представления Celesta создаёт таблицу в базе данных, модифицируемую триггерами при изменении родительской таблицы.</p>
</div>
<div class="paragraph">
<p>Материализованные представления создаются при помощи синтаксической конструкции</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/950px-Create_materialized_view.png" alt="950px Create materialized view" width="100%">
</div>
</div>
<div class="paragraph">
<p>Основными ограничениями и отличиями такого запроса от SQL-запросов в различных СУБД являются:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Запросы строятся только на таблице текущей гранулы.</p>
</li>
<li>
<p>Конструкция SELECT * не поддерживается, и всякое поле запроса, если только это не ссылка на поле таблицы с уникальным в рамках запроса именем, должно иметь определённый и уникальный псевдоним. Это нужно для возможности однозначного создания класса-курсора, поля которого соответствуют именам столбцов запроса.</p>
</li>
<li>
<p>В выборке обязательно должен участвовать хотя бы один агрегатный и хотя бы один неагрегатный столбец.</p>
</li>
<li>
<p>Неагрегатные колонки должны ссылаться на not null колонки родительской таблицы.</p>
</li>
<li>
<p>Если в group by выражении участвует колонка типа datetime, то ее значения будут округляться в точности до дня (часы, минуты и более точные измерения отсекаются).</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Materialized_aggregate.png" alt="Materialized aggregate" width="80%">
</div>
</div>
</div>
<div class="sect3">
<h4 id="create_function_statement">1.5.10. Конструкция CREATE FUNCTION</h4>
<div class="paragraph">
<p>Функции — они же параметризованные представления. Служат для доступа только на чтение к данным, собранным из одной или нескольких таблиц при помощи SQL-запроса SELECT с учетом переданных параметров.</p>
</div>
<div class="paragraph">
<p>Функции создаются при помощи синтаксической конструкции</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Create_function.png" alt="Create function" width="100%">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Param_definition.png" alt="Param definition" width="50%">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Param_literal.png" alt="Param literal" width="30%">
</div>
</div>
<div class="paragraph">
<p>Основными ограничениями и отличиями такого запроса от SQL-запросов в различных СУБД являются:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Конструкция SELECT * не поддерживается, и всякое поле запроса, если только это не ссылка на поле таблицы с уникальным в рамках запроса именем, должно иметь определённый и уникальный псевдоним. Это нужно для возможности однозначного создания класса-курсора, поля которого соответствуют именам столбцов запроса.</p>
</li>
<li>
<p>В объявлении обязательно должен иметься хотя бы один параметр.</p>
</li>
<li>
<p>Все объявленные параметры обязательно должны использоваться.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>В остальном синтаксическое выражение аналогично обычному View.</p>
</div>
<div class="paragraph">
<p>Пример функции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE FUNCTION pView2(param int,/*TEST*/ param2 varchar) AS
  select f1, f2, f3 from t1
  where f2 = $param AND f3 = $param2 AND f3 = $param2;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_celestadoc">1.6. CelestaDoc</h3>
<div class="paragraph">
<p>Аналогично тому, как в языке Java можно документировать объекты кода при помощи JavaDoc, или в языке Python использовать документирующую константу, доступную затем во время выполнения, объекты вида «гранула» (GRAIN), «таблица» (TABLE), «поле таблицы» и «индекс» (INDEX) могут быть задокументированы при помощи комментариев в специальном формате: /** &#8230;&#8203; */ (две звёздочки после первого слэша, в отличие от одной звёздочки в простом комментарии). Эти комментарии называются CelestaDoc-комментариями (по аналогии с JavaDoc), и могут находиться в коде creation-скрипта непосредственно перед определениями соответствующих объектов, как в примере:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">/**описание гранулы*/
CREATE GRAIN test1 VERSION '1.0';
/**описание таблицы*/
CREATE TABLE table2(
    /**описание первой колонки*/
    column1 INT NOT NULL IDENTITY PRIMARY KEY,
    /**описание второй колонки*/
    column2 INT
);
 /**описание индекса idx1*/
CREATE INDEX idx1 ON  table2 (column2);
/**описание представления v1*/
CREATE VIEW v1 AS
  SELECT DISTINCT column2 FROM table2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В отличие от простых комментариев, которые можно использовать в любом месте creation-скрипта, CelestaDoc-комментарии допустимо использовать только перед определением соответствующего объекта, в противном случае возникает ошибка синтаксиса.</p>
</div>
<div class="paragraph">
<p>Синтаксический анализатор прочитывает CelestaDoc, и эта информация доступна в объектах метаданных в процессе выполнения при помощи метода <strong>getCelestaDoc()</strong> (см. раздел <a href="#Celesta_metadata">Метаданные Celesta</a>).</p>
</div>
<div class="paragraph">
<p>Цель комментариев CelestaDoc — снабжение объектов Celesta документацией и дополнительной метаинформацией — например, human readable названиями полей, информацией о том, как представлять поля в пользовательском интерфейсе и т. п.</p>
</div>
<div class="paragraph">
<p>Общепринятой практикой является запись в комментарии CelestaDoc информации в формате JSON-объекта. При этом CelestaDoc может содержать как обычный текст, так и JSON-объект. С помощью утилитного метода <code>ru.curs.celesta.score.CelestaDocUtils.getCelestaDocJSON</code> можно извлечь первый валидный JSON-объект из CelestaDoc-строки.</p>
</div>
</div>
<div class="sect2">
<h3 id="_контекст_вызова">1.7. Контекст вызова</h3>
<div class="paragraph">
<p>Для того, чтобы можно было реализовать требования распределения прав доступа и логирования действий, любая операция над данными в Celesta производится от имени некоторого пользователя, «анонимных» операций быть не может. Поэтому любой Celesta-код выполняется в некотором контексте вызова (CallContext).</p>
</div>
<div class="paragraph">
<p>Привязка имени пользователя к роли определяет разрешения на доступ к таблицам, а также обеспечивает возможность логирования изменений, производимых от его имени.</p>
</div>
<div class="paragraph">
<p>Каждая из процедур, вызываемых в Celesta, принимает в качестве аргумента объект <code>ru.curs.celesta.CallContext</code>. Этот объект предназначен в первую очередь для использования в качестве аргумента при вызове конструкторов курсоров. Cам этот объект имеет следующие публично доступные методы и атрибуты:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">commit()</dt>
<dd>
<p>фиксирует текущую транзакцию. Вызывать данный метод требуется только в редких случаях, когда транзакцию обработки данных необходимо разбить на несколько частей. Обычно в вызове этого метода необходимости нет, т. к. транзакция фиксируется автоматически по завершении процедуры.</p>
</dd>
<dt class="hdlist1">rollback()</dt>
<dd>
<p>откатывает текущую транзакцию.</p>
</dd>
<dt class="hdlist1">getCelesta()</dt>
<dd>
<p>вызывает текущий экземпляр объекта Celesta. Необходимо, например, для получения информации о метаданных.</p>
</dd>
<dt class="hdlist1">getUserId()</dt>
<dd>
<p>возвращает имя пользователя, от лица которого производятся действия.</p>
</dd>
<dt class="hdlist1">getStartTime()</dt>
<dd>
<p>возвращает время создания контекста вызова (время начала работы Celesta-процедуры).</p>
</dd>
<dt class="hdlist1">getDurationNs()</dt>
<dd>
<p>возвращает время жизни контекста вызова в наносекундах (необходимо использовать данный метод для точного замера времени выполнения процедур).</p>
</dd>
<dt class="hdlist1">getProcName()</dt>
<dd>
<p>возвращает имя процедуры, которая была изначально вызвана (используется для нужд отладки).</p>
</dd>
<dt class="hdlist1">getDBPid()</dt>
<dd>
<p>возвращает PID (process identifier) текущего соединения с базой данных (используется для нужд отладки).</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_работа_с_данными_через_классы_доступа_к_данным">1.8. Работа с данными через классы доступа к данным</h3>
<div class="sect3">
<h4 id="_классы_доступа_и_их_стандартные_методы">1.8.1. Классы доступа и их стандартные методы</h4>
<div class="paragraph">
<p>Для каждой из таблиц и представлений, объявленных в CelestaSQL, генерируются классы доступа к данным.</p>
</div>
<div class="paragraph">
<p>Каждый экземпляр класса доступа к данным (его мы также будем именовать «курсор») в каждый момент времени хранит информацию об одной записи (строке) в базе данных. Курсор можно передвигать по записям с учётом фильтров и сортировок. Если курсор создан для таблицы, его также можно использовать для вставки, модификации и удаления данных. В курсоре, созданном для представления, доступны только методы чтения записей.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/800px-Cursor.png" alt="800px Cursor" width="100%">
</div>
</div>
<div class="paragraph">
<p>На UML-диаграмме показана иерархия классов доступа к данным. В основе иерархии стоит класс BasicDataAccessor. Каждый класс курсоров наследуется от класса BasicCursor, класс Sequence от BasicDataAccessor:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Cursor</dt>
<dd>
<p>предназначен для работы с таблицами. Наследует все методы BasicCursor, а также добавляет ряд собственных методов для возможности модификации данных.</p>
</dd>
<dt class="hdlist1">ViewCursor</dt>
<dd>
<p>предназначен для работы с представлениями, никаких собственных методов к BasicCursor не добавляет.</p>
</dd>
<dt class="hdlist1">MaterializedViewCursor</dt>
<dd>
<p>предназначен для работы с материализованными представлениями. Наследует все методы BasicCursor, а также добавляет ряд собственных методов для возможности получения данных по первичному ключу.</p>
</dd>
<dt class="hdlist1">ParameterizedViewCursor</dt>
<dd>
<p>предназначен для работы с функциями(параметризованными представлениями). Никаких собственных методов к BasicCursor не добавляет, однако имеет отличный от базового класса конструктор.</p>
</dd>
<dt class="hdlist1">ReadOnlyTableCursor</dt>
<dd>
<p>предназначен для работы с таблицами, объявленными с опцией WITH READ ONLY, никаких собственных методов к BasicCursor не добавляет.</p>
</dd>
<dt class="hdlist1">Sequence</dt>
<dd>
<p>предназначен для работы с последовательностями. Наследует все методы класса BasicDataAccessor и добавляет метод nextValue.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Ниже описываются методы класса Cursor, но те методы, которые унаследованы от BasicCursor (и могут применяться при работе с представлениями и неизменяемыми таблицами) отмечены значком <span class="icon">[search]</span>.</p>
</div>
<div class="sect4">
<h5 id="_конструктор_курсора">Конструктор курсора</h5>
<div class="paragraph">
<p>Конструктор каждого курсора принимает в себя параметр <code>CallContext context</code>, который, в свою очередь, выдаётся каждому скрипту при начале работы. Использование context-а позволяет работать с разными таблицами системы в одной транзакции и затем единым образом коммитить все изменения, кроме того, переменная context содержит информацию о текущем пользователе, используемую системами логирования и разграничения прав доступа.</p>
</div>
<div class="paragraph">
<p>Так, для курсоров типов Cursor, ViewCursor, MaterializedViewCursor, ReadOnlyTableCursor конструктор вызывается следующим образом.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ACursor a = new ACursor(context);</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_ограничение_столбцов_в_выборке">Ограничение столбцов в выборке</h6>
<div class="paragraph">
<p>Очень часто в таблице определено много полей, но для нужд работы требуется лишь малая часть из них. Чтобы не передавать лишнюю информацию между базой и сервером приложений и увеличить быстродействие, курсоры можно создавать таким образом, чтобы получать из БД значения только нужных столбцов. Для этого в опциональный параметр курсора требуется передать массив названий полей, которые требуется извлекать. Поля, не указанные в этом массиве, будут принимать значение None.</p>
</div>
<div class="paragraph">
<p>Допустим, что в БД имеется заполненная данными таблица table1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">create table table1 (
  id int identity not null primary key,
  numb int not null,
  numb2 int,
  varr varchar(2) not null
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Допустим, что в создаваемом разработчиком решении, нет необходимости в выборке данных из столбца varr. В этом случае при создании курсора можно указать список столбцов, которые необходимы. Создание такого курсора будет выглядеть так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Set&lt;String&gt; set = Stream.of("numb", "numb2").collect(Collectors.toSet());
Table1Cursor tableCursor = Table1Cursor(context, set);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь при любом запросе данных из БД celesta не будет выбирать столбец <code>varr</code>, а в курсоре <code>tableCursor</code> поле <code>varr</code> всегда будет иметь значение None.</p>
</div>
<div class="paragraph">
<p>Некоторые особенности ограничения столбцов в выборке:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Колонки, являющиеся частью первичного ключа, всегда будут попадать в курсор из БД, независимо от того, указаны они в списке необходимых полей или нет. Это сделано для корректной работы метода navigate курсоров при ограничении колонок.</p>
</li>
<li>
<p>Колонки, являющиеся частью group by выражения материализованных представлений (materialized view) всегда будут попадать в курсор из БД.</p>
</li>
<li>
<p>При передаче пустого списка полей или при его отсутствии будут выбираться все колонки.</p>
</li>
<li>
<p>Использование столбцов с типом [BLOB-поля|blob] не изменяется. Данные из этих столбцов можно получать, как и раньше, отдельным методом.</p>
</li>
</ol>
</div>
</div>
<div class="sect5">
<h6 id="_передача_параметров_в_функции">Передача параметров в функции</h6>
<div class="paragraph">
<p>Стоит отметить, что курсор ParameterizedViewCursor имеет собственную версию конструктора, принимающую набор именованных аргументов - параметров функции.</p>
</div>
<div class="paragraph">
<p>Допустим имеется таблица и функция для выборки из нее.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE table t1 (
  id INT NOT NULL IDENTITY PRIMARY KEY,
  f1 int,
  f2 int,
  f3 VARCHAR (2)
);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE FUNCTION pView1(p int) AS
  select sum (f1) as sumv, f3 as f3
  from t1 as t1
  where f2 = $p
  group by f3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тогда для создания курсора для функции с параметром p = 5 необходимо выполнить следующий код.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PView1Cursor pView1 = PView1Cursor(context, 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Передачу параметров функции можно комбинировать с ограничением полей выборки: для этого сначала надо в обязательных аргументах курсора перечислить параметры, а последним — опциональным — аргументом передать список полей, которые вы хотите выбрать.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_изменение_полей_курсора">Изменение полей курсора</h5>
<div class="paragraph">
<p>По количеству объявленных полей в классе курсора имеются <strong>атрибуты</strong>, позволяющие читать и записывать информацию в поля курсора. Так, если таблица foo определена следующим образом</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE foo (
  a INT NOT NULL PRIMARY KEY,
  b VARCHAR(10),
  c DATETIME,
  d BIT
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>то для того, чтобы вставить запись в таблицу foo, можно использовать следующий код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FooCursor foo = FooCursor(context);
foo.setA(1);
foo.setB("text");
foo.setC(new GregorianCalendar(year, month, day).getTime());
foo.insert();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание на использование класса <code>Date</code> для записи значений даты. При необходимости заполнить поле "с" текущей датой и временем, это можно было бы сделать при помощи выражения</p>
</div>
<div class="paragraph">
<p>foo.setC(new Date());</p>
</div>
<div class="paragraph">
<p>То, как изменить значение BLOB-поля, описано в статье <a href="#BLOB_fields">BLOB-поля</a>.</p>
</div>
<div class="paragraph">
<p>Отдельный атрибут <code>getRecversion()</code> в курсоре существует для значения системного поля recversion, необходимого для механизма <a href="#Lost_updates_protection">защиты от потерянных обновлений</a>.</p>
</div>
<div class="paragraph">
<p>Каждый курсор имеет следующие методы (<span class="icon">[search]</span> обозначены методы, унаследованные от BasicCursor, которые могут применяться при работе с представлениями и таблицами «только на чтение»):</p>
</div>
</div>
<div class="sect4">
<h5 id="_закрытие_курсора">Закрытие курсора</h5>
<div class="ulist">
<ul>
<li>
<p><span class="icon">[search]</span> <strong>close()</strong> — закрытие курсора. Данный метод высвобождает все JDBC-ресурсы, аллоцированные во время существования курсора. Обращение к методам закрытого курсора приведёт к ошибке. Данный метод вызывать не обязательно, т. к. он вызывается автоматически после выполнения Celesta-процедуры на всех курсорах, созданных во время её выполнения. Вообще, предпочтительной практикой программирования является создание как можно меньшего числа курсоров в процедуре и повторное их использование. Тем не менее, если есть необходимость в создании большого числа курсоров, то возникает необходимость и в использовании метода close() в тот самый момент, когда экземпляр курсора становится ненужным.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_методы_переходов_по_записям">Методы переходов по записям</h5>
<div class="ulist">
<ul>
<li>
<p><strong>tryGet(Object&#8230;&#8203; values)</strong> Осуществляет поиск записи по ключевым полям, возвращает true, если запись найдена, и false, если записи с таким первичным ключом нет в таблице. В аргументах этого метода должны быть перечислены значения полей первичного ключа, количество аргументов должно быть равно количеству полей первичного ключа таблицы. ВНИМАНИЕ! Данный метод не учитывает никаких фильтров, наложенных на таблицу. Если вам необходимо найти запись с учётом фильтров, то используйте метод [try]First.</p>
</li>
<li>
<p><strong>get(Object&#8230;&#8203; values)</strong> То же, что tryGet, но выбрасывает исключение, если запись не найдена.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>navigate(command)</strong> — осуществляет переход по записям относительно текущего положения. Возвращает True, если переход удачный, и False — если записи не оказалось. При этом строка command может представлять собой произвольный набор из следующих символов, каждый из которых выполняется до тех пор, пока запись не нашлась:</p>
<div class="ulist">
<ul>
<li>
<p>- (минус) — переход к первой записи, удовлетворяющей условиям сортировки и фильтрации,</p>
</li>
<li>
<p>+ (плюс) — переход к последней записи,</p>
</li>
<li>
<p>&gt; — переход к следующей записи, относительно текущей, удовлетворяющей условиям сортировки и фильтрации,</p>
</li>
<li>
<p>&lt; — переход к предыдущей записи,
= — обновление текущей записи, если она попадает в текущий фильтр.</p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="icon">[search]</span> <strong>tryFirst()</strong> — то же, что navigate('-').</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>first()</strong> — то же, что tryFirst(), но вызывает ошибку, если запись не найдена.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>tryLast()</strong> — то же, что navigate('+').</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>last()</strong> — то же, что tryLast(), но вызывает ошибку, если запись не найдена.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>next()</strong> — то же, что navigate('&gt;').</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>previous()</strong> — то же, что navigate('&lt;').</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>tryFindSet()</strong> — открывает на сервере набор записей (recordset) и устанавливает курсор в его начало. Возвращает True, если открывшийся набор не пуст, False — если записей в наборе нет.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>findSet()</strong> — то же, что tryFindSet(), но вызывает ошибку в случае, если переход неудачен.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>nextInSet()</strong> — переход к следующей записи в текущем наборе данных на сервере. Если набор не открыт, вызов этого метода эквивалентен вызову tryFindSet(). Возвращает True, если переход состоялся, False — если достигнут конец набора.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>iterator()</strong> — возвращает итератор, позволяющий осуществить полную итерацию по набору записей с первой до последней. Например, если переменная rec содержит экземпляр курсора, то полная итерация с использованием метода iterate() может быть осуществлена следующим образом:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> for (FooCursor r: rec): {
         /* здесь внутри цикла всё,
          что вы хотите сделать с записями r */
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>что будет полностью эквивалентно следующему коду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (cursor.tryFindSet()) {
    while (cursor.nextInSet()) {
        //цикл
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Замечание</div>
</td>
<td class="content">
<em>В чём разница между <code>[try]First()</code> и <code>[try]FindSet()</code>?</em> — Разница в отправляемом на БД запросе. [try]First() (а также navigate(), next(), last()&#8230;&#8203;) выполняет запрос вида SELECT TOP 1, запрашивают одну запись и сразу закрывают на сервере recordset. Метод findSet() открывает на сервере recordset и держит его для того, чтобы его можно было бы обойти при помощи метода iterate().
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Замечание</div>
</td>
<td class="content">
<em>Чем <code>navigate("=")</code> отличается от <code>tryGet(_currentKeyValues())</code>?</em> — Метод navigate() учитывает текущие фильтры, а get() — не учитывает. Запись с текущим значением первичного ключа может не попасть в фильтр, поэтому navigate('=') может вернуть False в ситуации, когда tryGet(_currentKeyValues()) возвращает True.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Замечание</div>
</td>
<td class="content">
<em>Что значит <code>navigate("&#8658;&lt;")</code>?</em> — Эта команда предписывает следующий алгоритм: "Попытайся найти текущую запись. Если запись нашлась, выйди и верни True. Если записи уже нет (удалили), сходи вперёд. Если запись нашлась, выйди и верни True. Если впереди ничего нет, сходи назад. Если запись нашлась, верни <code>true</code>, если нет — <code>false</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_методы_сортировки_и_фильтрации">Методы сортировки и фильтрации</h5>
<div class="ulist">
<ul>
<li>
<p><span class="icon">[search]</span> <strong>setRange(String name)</strong> Сброс любого фильтра на поле.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>setRange(String name, Object value)</strong> Установка диапазона из единственного значения на поле. Передача значения None в качестве аргумента приводит к установке фильтра 'IS NULL' на данное поле.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>setRange(String name, Object valueFrom, Object valueTo)</strong> Установка диапазона «от..до включительно» на поле (на уровне языка SQL соответствует оператору BETWEEN). Использование None в качестве аргумента не допускается.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>setFilter(String name, String value)</strong> Установка сложного фильтра на поле, описание выражений сложных фильтров приведено ниже.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>setComplexFilter(String value)</strong> Установка сложного фильтра на таблицу. Аргумент соответствует условию WHERE на языке CelestaSQL.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>setIn(BasicCursor auxiliaryCursor)</strong> Установка фильтра с вложенным запросом.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>limit(skip, limit)</strong> Установка ограничений на возвращаемый диапазон строк. В качестве параметров должны быть неотрицательные целые числа. Параметр skip означает количество строк, которое будет пропущено перед тем, как начнётся выдача (skip = 0 — выдача с самого начала), limit — максимальное число возвращаемых строк, при этом limit = 0 означает возврат <strong>всех</strong> строк. Вызов limit(0, 0) сбрасывает ограничения на возвращаемый диапазон набора строк. Ограничения, установленные методом limit(), не учитываются при вызове метода count().</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>orderBy(String&#8230;&#8203; names)</strong> Установка сортировки. Параметры — перечень имён полей для сортировки. Чтобы указывать сортировку по возрастанию или по убыванию, после каждого имени поля допускается добавлять ключевые слова ASC и DESC (ключевые слова могут быть в любом регистре, могут быть отделены от имени поля одним или несколькими пробелами). Если ключевое слово ASC/DESC не указано явно, сортировка идёт по возрастанию. Допускается вызов <strong>orderBy()</strong> без аргументов, чтобы сбросить все установленные ранее сортировки на сортировку по умолчанию. Имя поля можно указать не более чем в одном из аргументов метода <strong>orderBy(&#8230;&#8203;)</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Следует помнить, что в Celesta не бывает не отсортированных наборов данных: по умолчанию наборы данных в Celesta всегда сортируются по полям первичного ключа, а к любому набору полей, заданному через orderBy(&#8230;&#8203;), Celesta автоматически добавляет в конец те поля первичного ключа, которые не были перечислены в аргументах. Для представлений и «WITH READ ONLY» таблиц, у которых поля первичного ключа не заданы, Celesta использует для сортировки по умолчанию первое поле. Всё это реализовано для того, чтобы итерация по записям курсора была детерминированной.</p>
</div>
</div>
<div class="sect4">
<h5 id="_методы_инициализации">Методы инициализации</h5>
<div class="ulist">
<ul>
<li>
<p><span class="icon">[search]</span> <strong>reset()</strong> Сброс фильтров и сортировки, с сохранением значений полей буфера.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>clear()</strong> Сброс фильтров, сортировки и полная очистка буфера, включая ключевые поля.</p>
</li>
<li>
<p><strong>init()</strong> Очистка всех полей буфера, кроме ключевых.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_методы_клонирования">Методы клонирования</h5>
<div class="ulist">
<ul>
<li>
<p><span class="icon">[search]</span> <strong>copyFiltersFrom(c)</strong> Перенос значений всех фильтров, включая значения limit (skip и limit), из курсора с тем же типом в текущий курсор.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>copyOrderFrom(c)</strong> Перенос настроек сортировки из курсора с тем же типом в текущий курсор.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>copyFieldsFrom(c)</strong> Перенос значений всех полей из курсора с тем же типом в текущий курсор.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_методы_модификации_данных">Методы модификации данных</h5>
<div class="ulist">
<ul>
<li>
<p>insert() Вставка содержимого курсора в БД. При этом если запись с таким первичным ключом уже существует, возникает ошибка.</p>
</li>
<li>
<p>tryInsert() Вставка содержимого курсора в БД. true если получилось, false если запись с таким первичным ключом уже существует</p>
</li>
<li>
<p>update() Сохранение содержимого курсора в БД, выбрасывая исключение в случае, если запись с такими ключевыми полями не найдена.</p>
</li>
<li>
<p>tryUpdate() Сохранение содержимого курсора в БД, true если получилось, false если запись с таким первичным ключом не существует.</p>
</li>
<li>
<p>delete() Удаление текущей записи.</p>
</li>
<li>
<p>deleteAll() Удаление всех записей, попадающих в фильтр. NB. Триггер onDelete при этом не вызывается.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_вспомогательные_методы">Вспомогательные методы</h5>
<div class="ulist">
<ul>
<li>
<p><span class="icon">[search]</span> <strong>canRead(), canInsert(), canModify(), canDelete()</strong> Возвращает булевское значение, указывающее на наличие прав у текущей сессии на выполнение соответствующей операции.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>count()</strong> Возвращает количество записей в отфильтрованном наборе. В частности, если фильтров на курсор не установлено, возвращает полное количество записей в таблице. Ограничения на набор записей, установленные методом limit(), не учитываются при вызове метода count().</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>callContext()</strong> Возвращает контекст вызова, на котором создан данный курсор.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>_tableName()</strong> Возвращает имя таблицы или представления.</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>meta()</strong> Возвращает описание таблицы или представления (метаинформацию, экземпляр класса ru.curs.celesta.score.Table/View).</p>
</li>
<li>
<p><span class="icon">[search]</span> <strong>asCSVLine()</strong> Возвращает значение полей курсора в виде CSV-строки с разделителями-запятыми.</p>
</li>
<li>
<p><strong>getMaxStrLen(String name)</strong> Возвращает длину текстового поля (в символах). Выбрасывает ошибку, если в параметр передано имя несуществующего или не текстового поля. Возвращает -1, если поле определено как NVARCHAR(MAX).</p>
</li>
<li>
<p><strong>getXRec()</strong> Возвращает копию буфера, содержащую значения, полученные при последнем чтении данных из базы.</p>
</li>
<li>
<p><strong>resetIdentity(int newValue)</strong> Устанавливает текущее значение счётчика IDENTITY на таблице (если он есть). Параметр newValue задаёт значение, которое должно принять поле IDENITITY при следующей вставке. Этот метод предназначен для реализации механизмов экспорта-импорта данных из таблицы. Его следует применять с осторожностью, т.к. сбой в отсчёте IDENTIY-счётчика может привести к нарушению первичного ключа. Кроме того, как минимум в Oracle, в силу особенностей реализации, не гарантируется надёжная работа этого метода в условиях конкуретного доступа к таблице.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Важно</div>
</td>
<td class="content">
Обратите внимание, что методы get, first, insert, update имеют два варианта: без приставки try (просто get(&#8230;&#8203;) и т. д.) и с приставкой try (tryGet(&#8230;&#8203;), tryFirst() и т. д.).
Методы без приставки try вызывают исключение, если в базе данных нет подходящих данных для выполнения действия. К примеру, first() вызовет исключение, если в установленный на курсор фильтр не попадёт ни одной записи (или, в вырожденном случае, если таблица окажется пуста). Методы get и update вызовут исключение в случае отсутствия соответствующей записи, а метод insert — если запись с таким набором значений полей первичного ключа уже существует. В то же время методы с приставкой try исключения не вызывают, а вместо этого возвращают булевское значение, сигнализирующее об успешности или неуспешности соответствующей операции.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Важно</div>
</td>
<td class="content">
Правильной практикой при разработке кода бизнес-логики является использование методов БЕЗ приставки <code>try</code> везде, где это возможно. Таким образом создаётся «самотестирующийся» код, вовремя сигнализирующий об ошибках в логике и/или в данных базы данных. К примеру, если при разработке процедуры мы предполагаем, что если приложение работает верно, то в переменной <code>idFoo</code> содержится идентификатор записи, существующей в таблице <code>foo</code>, то для получения самой записи следует писать <code>foo.get(idFoo)</code>. В этом случае, если где-то в программе есть ошибка, приводящая к тому, что idFoo может принимать значение несуществующего идентификатора, об этом будут проинформированы разработчики и пользователи в самый момент возникновения данной ситуации. <em>«Маскировка» возможных проблем путём использования try&#8230;&#8203;-метода без явной нужды в возвращаемом значении этого метода является грубой ошибкой, которая приведёт к общему запутыванию отладки и дестабилизации кода.</em> Разумеется, иногда в коде нужно выяснить — есть ли запись с таким идентификатором? Для этого — и только для этого — предназначен <code>tryGet</code>, аналогичное справедливо для других «<code>try</code>-методов», использование которых в подавляющем большинстве случаев оправдано только если предполагается явное использование возвращаемых значений этих методов.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_использование_метода_setfilter">1.8.2. Использование метода setFilter</h4>
<div class="paragraph">
<p>В большинстве практических случаев фильтрацию курсоров по значению поля можно выполнять при помощи методов <code>setRange(&#8230;&#8203;)</code> с двумя или тремя параметрами, отфильтровывающих значения по условию вида «поле = значение» либо по условию вида «поле between значение1 and значение2».</p>
</div>
<div class="paragraph">
<p>В случаях, когда простого сравнения или условия between недостаточно, метод <code>setFilter</code> позволяет наложить сложное логическое условие на значения в одном из полей курсора. Первым аргументом метода <code>setFilter</code> является имя поля, а вторым — выражение фильтра.</p>
</div>
<div class="paragraph">
<p>Правильное выражение фильтра может состоять из:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>числовых либо текстовых литералов (в зависимости от типа поля),</p>
</li>
<li>
<p>литерала null,</p>
</li>
<li>
<p>логических операторов &amp;, |, !,</p>
</li>
<li>
<p>операторов сравнения &lt;, &gt;, ..,</p>
</li>
<li>
<p>группирующих скобок (, ),</p>
</li>
<li>
<p>специальных операторов @ и % для текстовых полей.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Выражение фильтра не может быть null или пустой строкой, для сброса фильтра с поля следует вызывать метод setRange с одним параметром. Пробелы между литералами и операторами игнорируются. Выражение фильтра напрямую, без предварительной оптимизации, транслируется в условие для выражения WHERE языка SQL.</p>
</div>
<div class="sect4">
<h5 id="_выражения_фильтра_для_полей_с_типами_bit_и_blob">Выражения фильтра для полей с типами BIT и BLOB</h5>
<div class="paragraph">
<p>Для полей с типами BIT и BLOB допустимо использование выражения фильтров вида null и !null, отфильтровывающие значения «поле is null» и «not (поле is null)»:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/01.simple_filter.png" alt="01.simple filter" width="30%">
</div>
</div>
<div class="paragraph">
<p>Иные виды фильтрации для типа BLOB смысла не имеют, а для битового типа условие на True или False накладывается с помощью метода <strong>setRange(&#8230;&#8203;)</strong>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_выражения_фильтра_для_полей_с_типами_integer_и_real">Выражения фильтра для полей с типами INTEGER и REAL</h5>
<div class="paragraph">
<p>Для полей с типами INTEGER и REAL допустимо использование выражений фильтров по следующим синтаксическим правилам:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/02.filter.png" alt="02.filter" width="60%">
</div>
</div>
<div class="paragraph">
<p>Здесь</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&amp; — знак логического И,</p>
</li>
<li>
<p>| — знак логического ИЛИ,</p>
</li>
<li>
<p>! — знак логического НЕ,</p>
</li>
<li>
<p>(, ) — группирующие скобки.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Выражение <strong>term</strong> для числовых полей имеет следующий синтаксис:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/03.numeric_term.png" alt="03.numeric term" width="80%">
</div>
</div>
<div class="paragraph">
<p>Например, выражение фильтра</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">(10|&lt;5)&amp;&gt;0</code></pre>
</div>
</div>
<div class="paragraph">
<p>для поля с именем "foo" будет переведено в условие</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">("foo" = 10 or "foo" &lt; 5) and "foo" &gt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Знаки "&gt;" и "&lt;", естественно, задают условия «строго больше» и «строго меньше», а использование символа ".." позволяет задавать условия «больше или равно» и «меньше или равно». Так, фильтр</p>
</div>
<div class="listingblock">
<div class="title">.0|5..7|10..</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">будет транслирован в условие</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">"foo" &lt;= 0 or "foo" between 5 and 7 or "foo" &gt;= 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>(напоминаем, что оператор between в SQL задаёт диапазон с включением границ).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Важно</div>
</td>
<td class="content">
Обратите внимание, что выражение фильтра требует явной группировки скобками разных логических операторов, т. е. корректными являются выражения
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">(10|&lt;5)&amp;&gt;0
10|(&lt;5&amp;&gt;0)
10|&lt;5|&gt;0</code></pre>
</div>
</div>
<div class="paragraph">
<p>но вызовет ошибку выражение</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">10|&lt;5&amp;&gt;0</code></pre>
</div>
</div>
<div class="paragraph">
<p>в котором нет группирующих скобок, явно указывающих на последовательность вычисления операторов ИЛИ и И.</p>
</div>
</div>
<div class="sect4">
<h5 id="_выражения_фильтра_для_полей_с_типом_datetime">Выражения фильтра для полей с типом DATETIME</h5>
<div class="paragraph">
<p>Выражения фильтра для полей с типом DATETIME имеют такой же синтаксис, что и для числовых полей, но вместо числового нумерала <strong>&lt;numeric literal&gt;</strong> следует использовать нумерал даты в виде 'YYYYMMDD' (апостроф, восемь цифр, апостроф). Таким образом, правильные выражения фильтров для поля даты выглядят так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">'20131124'
'20131124'..'20151211'|'20111111'
(&gt;'20131124'&amp;..'20151211')|'20111111'..</code></pre>
</div>
</div>
<div class="paragraph">
<p>Разные типы СУБД по-разному работают с литералами дат, но Celesta транслирует выражения фильтра в условия, корректно отрабатывающиеся каждой из поддерживаемых СУБД.</p>
</div>
</div>
<div class="sect4">
<h5 id="_выражения_фильтра_для_полей_с_типом_varcharn_и_text">Выражения фильтра для полей с типом VARCHAR(n) и TEXT</h5>
<div class="paragraph">
<p>Выражения фильтра для текстовых полей в целом похожи на выражения фильтра для числовых полей, с той лишь разницей, что вместо чисел в выражениях термов надо указывать строковые литералы в одинарных кавычках. Например, на текстовом поле корректным является фильтр <strong>'aa'|'bb'|'cc'</strong>, который отфильтрует записи, в которых значения фильтруемого поля равны "aa", "bb" или "cc". При этом, если нужно отфильтровать текст, содержащий одинарную кавычку, то её в текстовом литерале (как и обычно в языке SQL) следует удвоить: для отбора значений "John&#8217;s company" следует писать 'John''s company'. Как и все прочие типы полей, текстовые поля можно фильтровать по значению null/ not null при помощи термов null/!null.</p>
</div>
<div class="paragraph">
<p>Кроме того, текстовые поля можно фильтровать при помощи оператора LIKE, применяя специальный символ %, означающий любую комбинацию любых символов, а также при помощи специального символа @ указывать на независимость фильтра от регистра.</p>
</div>
<div class="paragraph">
<p>Более точно, синтаксические правила термов фильтра для текстовых полей выглядят следующим образом:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/04.text_term.png" alt="04.text term" width="80%">
</div>
</div>
<div class="paragraph">
<p>Так, выражение</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">('aaa'&amp;'bb')|(!'ddd'&amp;!null)</code></pre>
</div>
</div>
<div class="paragraph">
<p>будет транслировано в</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">(("foo" = 'aaa' and "foo" = 'bb') or (not ("foo" = 'ddd') and not ("foo" is null))</code></pre>
</div>
</div>
<div class="paragraph">
<p>(что естественно никогда не будет выполнено, этот и следующий примеры даны лишь для иллюстрации принципа трансляции фильтров в язык SQL).</p>
</div>
<div class="paragraph">
<p>Выражение</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">@'q'|@..'cC'|@'Ff'..|@'a'..'b'|@%'5a'|'abc'%|! @ %'ef'%|null</code></pre>
</div>
</div>
<div class="paragraph">
<p>использующее знаки @, транслируется в</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">UPPER("foo") = 'Q' or UPPER("foo") &lt;= 'CC' or UPPER("foo") &gt;= 'FF' or UPPER("foo") between 'A' and 'B'
or UPPER("foo") like '%5A' or "foo" like 'abc%' or not (UPPER("foo") like '%EF%') or "foo" is null</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_использование_метода_setin">1.8.3. Использование метода setIn</h4>
<div class="paragraph">
<p>Метод <strong>setFilter</strong> позволяет фильтровать записи, некоторое поле которых принимает любое значение из заранее заданного набора. К примеру,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">myCursor.setFilter('city_id', "'MSK'|'LON'")</code></pre>
</div>
</div>
<div class="paragraph">
<p>отфильтровывает записи, поле «код города» которых принимает значение MSK или LON. Вызов</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">myCursor.setFilter('city_id', "'M'%")</code></pre>
</div>
</div>
<div class="paragraph">
<p>отфильтровывает записи, код города в которых начинается с латинской буквы M.</p>
</div>
<div class="paragraph">
<p>Однако функциональности <strong>setFilter</strong> бывает недостаточно: что если необходимо отфильтровать записи, относящиеся к городам, полное название которых на русском языке начинается с буквы «Ф»?</p>
</div>
<div class="paragraph">
<p>Одним из способов решения такой задачи могло быть следующее: отфильтровать справочник городов по city.setFilter('name', "'Ф'%"), далее выгрузить из базы данных в память полный набор идентификаторов таких городов, объединить их в строку фильтра через вертикальную черту, и использовать это как фильтр на другом курсоре. Ясно, что такой подход плох, если попадающих в фильтр записей слишком много: это породит обмен лишними данными по сети и слишком длинный SQL-запрос к интересующей нас таблице.</p>
</div>
<div class="paragraph">
<p>Для этого случая применяется метод <strong>setIn</strong>, который позволяет установить фильтр с вложенным запросом по указанному набору полей. Доступен для наследников классов Cursor и ViewCursor.</p>
</div>
<div class="paragraph">
<p>Общая схема работы с <strong>setIn</strong> такова:</p>
</div>
<div class="paragraph">
<p>устанавливаются фильтры на целевом и вспомогательных курсорах,
устанавливается связь полей между целевым и вспомогательными курсорами.
Связь полей задается при помощи вспомогательного класса FieldsLookup, возвращаемого в качестве результата из метода setIn целевого курсора. Метод setIn принимает в качестве единственного аргумента объект вспомогательного курсора, по которому ищется пересечение. Подготовка целевого курсора и аккумулирование пар столбцов с последующей установкой фильтра происходит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">from _filters_orm import TargetCursor, AuxiliaryCursor
a = TargetCursor(context)
b = AuxiliaryCursor(context)
b.setRange('foo', 'bar')
lookup = a.setIn(b).add("a1", "b1").add("a2", "b2")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для данного примера в PostgreSQL, например, для доступа к строкам курсора <code>a</code> будет сгенерировано следующее sql выражение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT ... FROM Target WHERE ( a1, a2 ) IN (SELECT b1, b2 FROM Auxiliary WHERE Auxiliary.foo = 'bar' )</code></pre>
</div>
</div>
<div class="paragraph">
<p>К целевому курсору можно применить любое число вспомогательных курсоров через метод and класса <code>FieldsLookup</code>. При этом вспомогательные курсоры между собой никак не пересекаются. Пример задания нескольких вспомогательных курсоров ниже:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">TargetCursor a = TargetCursor(context);
a.setRange("afoo", "aBar");
AuxiliaryCursor b = AuxiliaryCursor(context);
b.setRange("bFoo", "bBar");
Auxiliary2Cursor c = Auxiliary2Cursor(context);
c.setRange("cFoo", "cBar");
FieldsLookup lookup = a.setIn(b).add("a1", "b1").add("a2", "b2");
FieldsLookup lookup2 = lookup.and(c).add("a1", "c1");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для данного примера в PostgreSQL, например, для доступа к строкам курсора a будет сгенерировано следующее sql выражение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT ...
FROM Target
WHERE aFoo = 'aBar'
    AND ( a1, a2 ) IN (SELECT b1, b2 FROM Auxiliary WHERE Auxiliary.bFoo = 'bBar' )
    AND (a1) IN (SELECT c1 FROM Auxiliary2 WHERE Auxiliary2.cFoo = 'cBar' )</code></pre>
</div>
</div>
<div class="paragraph">
<p>У данного фильтра имеется набор ограничений, несоблюдение которых приведёт к выбрасыванию исключения во время выполнения методов FieldsLookup.add или BasicCursor.setIn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Типы данных у каждой пары сопоставляемых полей должны в точности совпадать.</p>
</li>
<li>
<p>В каждой из таблиц должен существовать индекс, включающий в себя все столбцы из набора сопоставляемых столбцов: для примера выше для таблицы Target должен иметься индекс I1(a1, a2,..), для Auxiliary - I2(b1, b2,&#8230;&#8203;).</p>
</li>
<li>
<p>Для курсоров на таблицы соответствующие индексы должны содержать сопоставляемые столбцы в своём начале. Для нашего примера, если имеются индексы I1(a1, a2,..), I2(b1, b2,&#8230;&#8203;), следующий код вызовет исключение, т. к. поля a2, b2 находятся не в начале индексов I1 и I2:</p>
</li>
<li>
<p>Класс FieldsLookup может принять в себя курсоры только одного происхождения, т.е. либо оба курсора для работы с таблицами, либо оба курсора для работы с представлениями.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FieldsLookup lookup = setIn(b).add("a2", "b2");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_триггеры">1.8.4. Триггеры</h4>
<div class="paragraph">
<p>Триггером называется написанная создателем решения функция, принимающая в качестве аргумента экземпляр курсора, присоединённая к классу курсора, автоматически вызываемая при вставке, удалении и модификации записи.</p>
</div>
<div class="paragraph">
<p>При действиях insert(), update() и delete() система вызывает определённые создателем решения pre- (выполняемые до модификации данных в базе) и post- (выполняемые после модификации данных в базе) триггеры. Таким образом, всего существует шесть типов триггеров:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">pre-триггеры</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">post-триггеры</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">onPreInsert</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">onPostInsert</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">onPreUpdate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">onPostUpdate</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">onPreDelete</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">onPostDelete</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Важно</div>
</td>
<td class="content">
Чаще всего имеет смысл пользоваться pre-триггерами, чтобы выполнить некоторые действия до того, как изменение будет внесено в базу. Однако обратите внимание: т. к. триггер onPreInsert выполняется до отправки содержимого курсора в базу данных, то на момент его выполнения не заполняются значения полей, обладающих свойствами DEFAULT, GETDATE() и IDENTITY (для их автозаполнения средствами БД следует присваивать им значение None). В триггере onPostInsert эти поля уже будут заполнены.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>В триггере onPreUpdate удобно воспользоваться объектом xRec, чтобы определить, какие именно поля собираются быть изменёнными в таблице. В триггере onPostUpdate объектом xRec воспользоваться уже нельзя, т. к. он становится равным текущему буферу.</p>
</div>
<div class="paragraph">
<p>Триггеров каждого типа на одной таблице может быть сколько угодно. Триггер для любой таблицы может быть определён в любом питоновском модуле любого пакета/гранулы, например, так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql"> def testTrigger(rec):
     print 'Test trigger is run on record with field1 = %s' % rec.field1</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Единственным ограничением на процедуру триггера является то, что она должна принимать один аргумент, который может быть интерпретирован, как курсор нужного типа).</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример того, как следует присоединять триггеры к классам таблиц.</p>
</div>
<div class="paragraph">
<p>Предположим, что в грануле g1 определена таблица aa — это значит, что в пакете g1 существует модуль  _g1_orm.py с классом aaCursor. Пусть триггер с названием testTrigger определён в модуле hello.py из того же пакета. Значит, в модуле <em>init.py</em>  пакета g1 необходимо написать следующий код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql"> from . import _g1_orm
 from . import hello
 _g1_orm.aaCursor.onPreInsert.append(hello.testTrigger)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание на конструкцию "from . import&#8230;&#8203;" для импорта имён из текущего пакета. Только такая форма будет работоспособной в модуле <em>init.py</em>, явное использование имени g1 вместо точки может привести к ошибкам «имя не определено».</p>
</div>
<div class="paragraph">
<p>Атрибуты onPreInsert, onPostInsert и т. д. являются статическими атрибутами каждого класса-курсора, по умолчанию являющими собой пустой массив. В модуле <em>init.py</em> эти массивы следует заполнять ссылками на функции-триггеры, это даст возможность системе в момент выполнения вызывать все присоединённые к таблицам триггеры, которых может быть несколько и которые могут быть определены в различных частях кода решения.</p>
</div>
<div class="paragraph">
<p>Системные курсоры также поддерживают данные триггеры. Но в силу того, что это Java классы, работать с ними нужно слегка иначе. Триггеры регистрируются через статические методы системных курсоров. Ниже приведен простой пример использования этого API.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql"> from ru.curs.celesta.syscursors import LogCursor
 from . import hello
 LogCursor.onPreInsert(hello.testTrigger)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_объект_xrec">1.8.5. Объект xRec</h4>
<div class="paragraph">
<p>Объект xRec, получаемый с помощью метода getXRec(), предназначен преимущественно для использования в триггере onPreUpdate. Сравнивая поля xRec с текущими значениями полей, можно определить, что именно изменилось в записи.</p>
</div>
<div class="paragraph">
<p>xRec хранит значения полей, полученные при последнем чтении курсора из базы данных (в отличие от основного буфера, поля которого после чтения равны полям xRec, но затем изменяются, когда пользователь присваивает им новые значения). Обновление объекта xRec происходит только при следующих действиях:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[try]first(),</p>
</li>
<li>
<p>[try]get(),</p>
</li>
<li>
<p>next(),</p>
</li>
<li>
<p>[try]insert() (по сути после вставки система выполняет операцию get() для курсора, чтобы прочитать значения, выданные базой данных на поля IDENITY, GETDATE(), DEFAULT, обновляя и основной буфер, и xRec),</p>
</li>
<li>
<p>[try]update() (после обновления в БД xRec становится копией текущего курсора),</p>
</li>
<li>
<p>delete() (после обновления в БД xRec заполняется значением буфера, как он был до удаления).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Обратите внимание, что в pre- и post- триггерах значение xRec будет различным!</p>
</div>
</div>
<div class="sect3">
<h4 id="_класс_sequence">1.8.6. Класс Sequence</h4>
<div class="paragraph">
<p>Класс Sequence позволяет работать с последовательностями. В отличие от остальных классов доступа при кодогенерации вместо суффикса Cursor используется суффикс Sequence. Класс Sequence имеет единственный метод nextValue, позволяющий получить следующее значение последовательности в виде типа long.</p>
</div>
<div class="paragraph">
<p>Ниже приведен пример использования класса доступа Sequence</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE GRAIN sequences version '1.0';
CREATE SEQUENCE idNumerator START WITH 3;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">from sequences._sequences_orm import idNumeratorSequence
idNumerator = idNumeratorSequence(context)
id = idNumerator.nextValue()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_распределение_прав_доступа_и_протоколирование_изменений">1.8.7. Распределение прав доступа и протоколирование изменений</h4>
<div class="paragraph">
<p>Работа с данными через классы доступа к данным даёт не только возможность писать универсальный, не зависящий от используемой СУБД код, но также и решить задачу централизованного распределения прав доступа к данным таблиц и протоколирования изменений.</p>
</div>
<div class="paragraph">
<p>Вызов ряда методов требует наличия соответствующих прав у пользователя на таблицы, прописанных в системных таблицах celesta.userroles и celesta.permissions, в противном случае возникает исключение PermissionDeniedException с сообщением вида "There is no &#8230;&#8203; permission for user &#8230;&#8203; on object &#8230;&#8203;".</p>
</div>
<div class="paragraph">
<p>Если протоколирование изменения таблицы настроено в таблице celesta.logsetup, то вызов некоторых методов будет приводить к созданиям записей в таблице celesta.log</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 57.1429%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Метод</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Требуемые права</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Протоколирование изменений</p>
<p class="tableblock">*</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[try]first(),
[try]get(),
next().</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">требуют право на чтение (r)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">не протоколируются</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">try]insert()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">требуют право на вставку (i)</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>протоколируется, если включён флаг i.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>oldvalues - пустое значение.</p>
</li>
<li>
<p>newvalues - вставляемая запись.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[try]update()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">требуют право на модификацию (m)</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>протоколируется, если включён флаг m.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>oldvalues - состояние записи до модификации.</p>
</li>
<li>
<p>newvalues - состояние записи после модификации.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete[All]()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">требуют право на удаление (d)</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>delete() протоколируется, если включён флаг d.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>oldvalues - состояние записи до удаление.</p>
</li>
<li>
<p>newvalues - пустое значение.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>deleteAll() не протоколируется и триггеры не выполняются</strong>.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Прочие методы не требуют никаких прав доступа к таблице и вызов их не протоколируется. Т. е. определить курсор, выставить на нём фильтры и даже подсчитать количество подпадающих под фильтры записей при помощи метода count() можно, даже не имея никаких прав на чтение таблицы.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="BLOB_fields">1.9. BLOB-поля</h3>
<div class="paragraph">
<p>BLOB-поля позволяют хранить в ячейке таблицы большие объёмы данных — например, целые файлы с документами. Работа с этими полями через курсор отличается от работы с полями других типов.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Атрибуты курсора, соответствующие BLOB-полям, должны принимать значения со специальным типом BLOB, и никак иначе. Присвоение этим атрибутам строк и значений иных типов приведёт к ошибке при попытке вызова методов insert() или update().</p>
</li>
<li>
<p>Получить экземпляр класса BLOB и присвоить его атрибуту курсора можно только одним способом: вызвав в курсоре метод calc&lt;имя поля&gt;(). Например, если BLOB-поле имеет название foo, то соответствующий метод курсора называется calcfoo(), и после его вызова будет заполнен атрибут foo.</p>
</li>
<li>
<p>В отличие от полей других типов, которые автоматически заполняются данными таблицы при чтении записи методами get(), next() и т. п., BLOB-поля при выполнении этих методов не заполняются, а всегда получают значение None. Чтобы прочитать BLOB-поле, необходимо вызвать метод calc&#8230;&#8203;(). При этом, если курсор указывает на существующую в таблице запись, вызов метода calc&#8230;&#8203;() приведёт к чтению содержимого BLOB-а из базы данных в оперативную память. Поэтому calc&#8230;&#8203;() следует вызывать лишь тогда, когда есть намерение прочитать или изменить содержимое BLOB-а.</p>
</li>
<li>
<p>После вызова метода calc&lt;имя поля&gt;(), соответствующий атрибут курсора инициализируется объектом с типом BLOB. Методы этого объекта позволяют читать и изменять его содержимое и описаны далее. После изменения содержимого объекта BLOB можно воспользоваться методом update() или insert().</p>
</li>
<li>
<p>Если BLOB необходимо стереть из базы данных, записав в соответствующую ячейку значение NULL, нужно воспользоваться методом setNull() объекта BLOB, а затем вызвать update(). Присвоение атрибуту значения None, в отличие от полей других типов, не сработает, т. к. будет проинтерпретировано системой, как если бы BLOB не был прочитан из базы, и по update() ничего не изменится.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Методы класса BLOB:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">getInStream()</dt>
<dd>
<p>возвращает экземпляр класса java.io.InputStream, из которого можно прочитать содержимое курсора или None, если в ячейке таблицы базы данных содержится значение NULL. Допускается многократный вызов этого метода, при этом всякий раз будет создаваться новый поток, читающий с начала.</p>
</dd>
<dt class="hdlist1">getOutStream()</dt>
<dd>
<p>стирает все данные BLOB-а в памяти (если они были) и создаёт экземпляр java.io.OutputStream, в который можно записать данные для BLOB-а. Следует подчеркнуть, что каждый вызов getOutStream() удаляет из BLOB-а в памяти все данные, даже если в полученный поток ничего не будет записано. Также следует подчеркнуть, что этот метод меняет данные только в представлении BLOB в оперативной памяти, реальная запись в базу данных происходит только после вызова методов insert() или update() на курсоре.</p>
</dd>
<dt class="hdlist1">setNull()</dt>
<dd>
<p>устанавливает для BLOB-а значение NULL.</p>
</dd>
<dt class="hdlist1">isModified()</dt>
<dd>
<p>возвращает true, если первоначальные данные объекта были изменены вызовами getOutStream() или setNull().</p>
</dd>
<dt class="hdlist1">size()</dt>
<dd>
<p>возвращает размер внутренних данных BLOB-а в байтах.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Примеры кода для работы с BLOB-полем:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">import java.io.OutputStreamWriter as OutputStreamWriter
import java.io.InputStreamReader as InputStreamReader
import java.io.BufferedReader as BufferedReader
c = cCursor(context)
#Далее подразумевается, что c.dat — BLOB-поле
. . .
#Пример записи
c.init()
c.calcdat()
osw = OutputStreamWriter(c.dat.getOutStream(), 'utf-8')
try:
    osw.append('hello, blob field!')
finally:
    osw.close()
c.insert()
. . .
#Пример чтения
c.calcdat()
ins = c.dat.getInStream()
if ins: #Помним о том, что в поле может быть NULL
    inr = BufferedReader(InputStreamReader(ins, 'utf-8'))
    print inr.readLine() #в консоль будет выведено содержимое курсора,
                     #например, "hello, blob field!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Option_fields">1.10. Option-поля</h3>
<div class="paragraph">
<p>Довольно часто в реляционных базах для бизнес-приложений необходимо иметь дело со случаем, когда какое-либо поле может принимать лишь несколько значений из фиксированного списка. Например, может оказаться так, что поле "state" в вашей таблице может принимать лишь значения "new, processing, finished, error", и никакие иные.</p>
</div>
<div class="paragraph">
<p>Т. к. список фиксированный, делать отдельный справочник и внешний ключ при этом не представляется разумным. Более того, для оптимизации объёма таблицы и скорости обработки, часто имеет смысл применять целочисленные поля, присваивая определённый "смысл" целочисленным значениям, например, так:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0 - new</p>
</li>
<li>
<p>1 - processing</p>
</li>
<li>
<p>2 - finished</p>
</li>
<li>
<p>3 - error</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Celesta поддерживает упрощённую работу с такими полями.</p>
</div>
<div class="paragraph">
<p>Чтобы объявить, что поле может принимать лишь значения из определённого списка, необходимо прописать свойство option в CelestaDoc целочисленного или текстового поля. Например, так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">create table foo
  ...
  /**целочисленное поле статуса
  {option: [new, processing, finished, error]}*/
  state int,
  /**текстовое поле статуса
  {option: [created, closed]*/
  state2 varchar(6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>При компиляции класса доступа к данным Celesta прочитывает свойство option и генерирует дополнительный код, упрощающий использование значений из списка.</p>
</div>
<div class="paragraph">
<p>Например, для нашей таблицы foo будут автоматически созданы два вложенных класса в классе fooCursor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">public static final class State {
    public static final Integer new = 0;
    public static final Integer processing = 1;
    public static final Integer finished = 2;
    public static final Integer error = 3;
    private State() {}
}
public static final class State2 {
    public static final String created = "created";
    public static final String closed = "closed";
    private State() {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание: для целочисленного поля возможные варианты автоматически нумеруются, а для текстового поля текстовые значения возможных вариантов буквально совпадают с их именами. Разработчик решения теперь может ссылаться на варианты значений следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FooCursor foo = new FooCursor(context)
foo.setRange("state", FooCursor.State.finished)
if (foo.state2 == FooCursor.State2.closed){
    ....
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Lost_updates_protection">1.11. Защита от потерянных обновлений</h3>
<div class="sect3">
<h4 id="_что_такое_потерянное_обновление_lost_update">1.11.1. Что такое потерянное обновление (lost update)?</h4>
<div class="paragraph">
<p>Чтобы проиллюстрировать понятие "потерянное обновление", рассмотрим следующий сценарий.</p>
</div>
<div class="paragraph">
<p>Допустим, в приложении имеется таблица с перечнем клиентов и пользователи могут редактировать эту таблицу через формы-карточки. Пусть события развиваются в следующей последовательности:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Пользователь А открывает карточку клиента для того, чтобы отредактировать его почтовый индекс.</p>
</li>
<li>
<p>Пользователь Б независимо от пользователя А на своей машине открывает карточку клиента для того, чтобы отредактировать значение его кредитного лимита.</p>
</li>
<li>
<p>Пользователь Б, изменив значение поля "кредитный лимит", сохраняет карточку. В базу данных записалась информация от пользователя Б, но пользователь А продолжает работу со своей копией карточки, где значение поля "кредитный лимит" ещё не обновилось.</p>
</li>
<li>
<p>Пользователь А заканчивает редактировать почтовый индекс клиента и сохраняет свою копию карточки. В базу данных сохраняются все поля карточки, в том числе старый кредитный лимит.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>В итоге получается, что работа пользователя Б потеряна!</p>
</div>
<div class="paragraph">
<p>Это наиболее расхожий пример, но на самом деле, разработчик решения может столкнуться с потерянными обновлениями и в гораздо более тривиальном случае, не в рамках многопользовательской работы. Предположим, что для модификации одной и той же таблицы используются два курсора:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">rec1 = FooTableCursor(context)
rec2 = FooTableCursor(context)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пусть в некий момент оба курсора получают данные об одной и той же записи, например, таким образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">rec1.get(1)
rec2.copyFieldsFrom(rec1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Допустим, запись таблицы FooTable с id = 1 состоит всего из трёх полей:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">id</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">field1</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">field2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">oldvalue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">oldvalue</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>И пусть теперь оба курсора выполняют модификации записи:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">rec1.field1 = 'newvalue'
rec1.update()
#в rec1 и в базе данных уже запись 1 | newvalue | oldvalue
#но в rec2 всё ещё                 1 | oldvalue | oldvalue
rec2.field2 = 'newvalue'
rec2.update()
#в базе данных теперь будет запись 1 | oldvalue | newvalue ???</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как видим, неудачно написанный код даже в рамках однопользовательской работы может столкнуться с явлением потери обновлений.</p>
</div>
</div>
<div class="sect3">
<h4 id="_способы_защиты_от_потерянных_обновлений">1.11.2. Способы защиты от потерянных обновлений</h4>
<div class="paragraph">
<p>Исторически для борьбы с явлением потерянного обновления сложились два метода:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Метод пессимистической блокировки (pessimistic lock) заключается в том, что при начале редактирования записи из какого-либо места в приложении, запись помечается как заблокированная, и никакой другой скрипт или пользователь не сможет начать редактирование до тех пор, пока предыдущий редактор не завершит свою работу, обновив запись или отказавшись от её редактирования.</p>
</li>
<li>
<p>Метод оптимистической блокировки (optimistic lock) заключается в том, что любому пользователю или скрипту в любое время разрешено начать редактирование записи, при этом в момент извлечения записи из базы данных извлекается и номер версии записи. В момент сохранения записи происходит проверка: если номер сохраняемой версии совпадает с таковым в базе данных, запись сохраняется и номер версии записи в базе данных инкрементируется; если же номер сохраняемой версии меньше, чем номер версии записи в базе данных, то пользователю выдаётся ошибка с сообщением о том, что кто-то поменял запись прежде и совет прочитать запись заново.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Каждый из методов, разумеется, имеет свои недостатки.</p>
</div>
<div class="paragraph">
<p>Главным недостатком оптимистической блокировки является, конечно, то, что пользователю не удастся записать результат своей работы в базу данных, если кто-то успел выполнить обновление той же самой записи прежде. Тем не менее, на практике это происходит в довольно редких случаях, и "страдают" от этого в основном лишь самые "нерасторопные" пользователи, у которых слишком большое время проходит от извлечения записи до завершения её редактирования.</p>
</div>
<div class="paragraph">
<p>Главным недостатком пессимистической блокировки является то, что от пользователя ожидается, что, начав редактирование записи, он явным образом завершит редактирование или откажется от него, сняв с записи блокировку. Однако на практике, если блокировка записи продолжается слишком долго, невозможно понять, какой из случаев имеет место:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>пользователь продолжает активную и сложную работу с записью и нужно ждать завершения его работы?</p>
</li>
<li>
<p>пользователю уже не нужно редактировать запись, но он просто забыл нажать на кнопку "отмена" и ушёл обедать/отправился в отпуск на две недели/уволился из организации?</p>
</li>
<li>
<p>у пользователя разорвалась связь с сервером/завис клиент/перезагрузился компьютер?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Во втором и третьем случаях требуется внешнее вмешательство и явное снятие блокировки силами администраторов, иначе другие пользователи не смогут работать с заблокированной записью. Случай 2 никогда нельзя исключать в организации, где работают живые люди, а случай 3 особенно вероятен в условиях клиент-серверной работы в Web-среде.</p>
</div>
<div class="paragraph">
<p>В целом для систем, подобных Celesta, недостатки пессимистической блокировки являются гораздо более существенными, чем недостатки оптимистической блокировки, и поэтому Celesta использует метод оптимистической блокировки для борьбы с потерянными обновлениями.</p>
</div>
</div>
<div class="sect3">
<h4 id="_защита_от_потерянных_обновлений_в_celesta">1.11.3. Защита от потерянных обновлений в Celesta</h4>
<div class="paragraph">
<p>По умолчанию, всякая таблица в системе Celesta снабжается системным полем recversion с типом INT NOT NULL.</p>
</div>
<div class="paragraph">
<p>Данное поле создаётся автоматически, разработчику не следует включать это поле в CREATE TABLE-скрипт. Более того, разработчик не может создать собственное поле с именем recversion. Доступ к этому полю имеется через классы доступа к данным, как к обычному полю.</p>
</div>
<div class="paragraph">
<p>При вставке новой записи поле recversion принимает значение по умолчанию 1 (единица).</p>
</div>
<div class="paragraph">
<p>При обновлении записи специальный триггер базы данных проверяет тот факт, что новое значение этого поля совпадает со значением, существующим в базе данных: если совпадение установлено, поле инкрементируется, если нет — генерируется ошибка:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code> Can not update &lt;имя гранулы и таблицы&gt; ([&lt;значения полей первичного ключа&gt;]): this record has been already modified by someone. Please start updating again.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В двух рассмотренных выше примерах Celesta выдаст ошибку и не даст отправить в базу данных запись, приводящую к потерянным обновлениям.</p>
</div>
<div class="paragraph">
<p>Иногда возникает необходимость отказаться от защиты от потерянных обновлений — например, если нет желания поддерживать системное поле recversion и специальные триггеры. В этом случае при создании таблицы на языке CelestaSQL необходимо использовать опцию WITH NO VERSION CHECK после определения таблицы.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Celesta_metadata">1.12. Метаданные Celesta</h3>
<div class="sect3">
<h4 id="_метаданные_и_их_динамическое_изменение">1.12.1. Метаданные и их динамическое изменение</h4>
<div class="paragraph">
<p>Экземпляр класса Celesta доступен через метод <strong>getCelesta()</strong> переменной context, передаваемой в качестве аргумента в каждую процедуру обработки данных.</p>
</div>
<div class="paragraph">
<p>Через метод <strong>getScore()</strong> экземпляра класса Celesta разработчик решения может получить доступ к метаданным системы, построенным при разборе «партитуры» (парсинге SQL-файлов). Доступ к метаданным необходим для двух целей:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>получения информации о текущей структуре базы данных во время выполнения кода бизнес-логики,</p>
</li>
<li>
<p>динамического изменения структуры базы данных.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Для динамического изменения структуры базы данных необходимо действовать в три этапа:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Используя описанные далее методы объектов метаданных, изменить объектную модель данных в памяти (ограничение: попытка изменения объектов системной гранулы "celesta" приведёт к ошибке).</p>
</li>
<li>
<p>Вызвать метод save() объекта Score. При этом система сериализует текущее состояние метаданных гранул в .sql-файлы партитуры Celesta, перезаписывая их текущее содержимое. <strong>Перезаписываться будут лишь файлы тех гранул, которые были изменены</strong>.</p>
</li>
<li>
<p>Вызвать статический метод <strong>reInitialize()</strong> класса Celesta. При этом происходит переинициализация объекта Celesta на основе новой партитуры и создание нового экземпляра-синглетона Celesta.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Следует понимать, что хотя Celesta не будет перезаписывать .sql-файл, если в этом нет нужды (если метаданные не были изменены), при перезаписи содержимого .sql-файлов происходит необратимая потеря комментариев и форматирования, существовавших в них ранее. Сохранены в тексте будут только CelestaDoc-комментарии. Поэтому динамическим изменением следует пользоваться с осторожностью, данная функциональность относится к продвинутым возможностям Celesta.</p>
</div>
</div>
<div class="sect3">
<h4 id="_состав_метаданных">1.12.2. Состав метаданных</h4>
<div class="paragraph">
<p>Все метаданные (Score) делятся на гранулы (Grain), состоящие из таблиц (Table), индексов (Index) и представлений (View).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Таблицы состоят из столбцов (Column) и содержат внешние ключи.</p>
</li>
<li>
<p>Индексы относятся к таблицам и состоят из их столбцов (Column).</p>
</li>
<li>
<p>Представления состоят из столбцов представлений (ViewColumnMeta), которые отличаются от столбцов таблиц, но имеют ряд общих свойств.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ниже представлена диаграмма классов, описывающих метаданные.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Score.png" alt="Score" width="100%">
</div>
</div>
<div class="paragraph">
<p>Базовым интерфейсом для столбцов таблиц и представлений является интерфейс ColumnMeta, с помощью которого можно узнать Celesta-тип данных столбца, его nullability и CelestaDoc, привязанный к данному столбцу. Данный интерфейс реализуют классы ViewColumnMeta для описания полей представлений и Column для описания полей таблиц.</p>
</div>
<div class="paragraph">
<p>Класс Column является абстрактным, и для шести типов полей, поддерживаемых Celesta, от него наследуются шесть субклассов:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Column.png" alt="Column" width="100%">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_методы_модификации_метаданных">1.12.3. Методы модификации метаданных</h4>
<div class="paragraph">
<p>Модификация метаданных во время выполнения возможна следующим образом:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 16.6668%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Тип объекта</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Методы добавления</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Методы модификации</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">Метод удаления</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Гранула</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Grain(score, name) —
конструктор создаёт объект-гранулу
с именем name, привязанную к score.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">setVersion(version) —
устанавливает тэг версии (version tag).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">метод отсутствует,
гранула может быть удалена только
физическим удалением папки
с гранулой из Score.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Таблица</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Table(grain, name) —
конструктор создаёт объект-таблицу
с именем name, привязанную к объекту-грануле grain.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">setPK(columnName, &#8230;&#8203;) —
устанавливает первичный ключ таблицы на основе переданного
массива имён столбцов. Попытка установки пустого
первичного ключа приводит к ошибке.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete() —
удаляет таблицу из гранулы</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Поле</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BinaryColumn(table, name)
BooleanColumn(table, name)
DateTimeColumn(table, name)
ZonedDateTimeColumn(table, name)
FloatingColumn(table, name)
DecimalColumn(table, name, precision, scale)
IntegerColumn(table, name)
StringColumn(table, name) —
создаёт поле нужного типа с именем name,
привязанное к объекту-таблице table.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">setNullableAndDefault(nullable, defaultValue) —
первый (булевский) аргумент этого метода управляет
свойством isNull, второй (строковый) — задаёт значение DEFAULT,
используя синтаксис соответствующего определения поля. Например,
для поля даты здесь допустимо использование слова GETDATE,
а для целочисленного поля — слово IDENTITY.
setLength(length) —
определён только для StringColumn,
устанавливает длину строки. Возможно использование
слова MAX в качестве длины.
setPrecision(precision) —
определён только для DecimalColumn,
устанавливает длину числа в символах.
setScale(scale) —
определён только для DecimalColumn,
устанавливает длину дробной части в символах.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete() —
удаляет поле из таблицы</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Внешний ключ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ForeignKey(parentTable, referencedTable, columnNames) —
конструктор создаёт объект-внешний ключ,
привязанный к таблице parentTable, ссылающийся на
referencedTable. В массиве строк columnNames
передаётся список имён столбцов, с которых идёт ссылка.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">setUpdateRule(updateRule)
setDeleteRule(deleteRule) —
устанавливает поведение внешнего ключа на обновление
или удаление записи, на которую есть ссылка
(SET NULL, CASCADE, NO_ACTION). В качестве аргумента
следует передавать одно из значений перечисления FKRule.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete() —
удаляет внешний ключ</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Индекс</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Index(table, name, columnNames) —
создаёт индекс на таблице table с именем name и списком
полей columnNames, передаваемом как массив строк.</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete() —
удаляет индекс</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Представление</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">View(grain, name, sql) —
создаёт представление в грануле grain, с именем name,
на основе sql-запроса sql.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Для того, чтобы изменить sql-запрос, на основе которого
сделано представление, удалите существующее
представление и создайте новое с тем же именем.
getCelestaQueryString() — возвращает SQL-запрос представления
getColumns() — возвращает перечень имён столбцов представления</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete() — удаляет представление</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>У каждого класса-наследника NamedElement (т. е. Grain, Table, Column и Index) имеются также методы <strong>getCelestaDoc()</strong> и <strong>setCelestaDoc()</strong> для чтения и установки документирующих данных CelestaDoc. При сохранении в файл динамически изменённых метаданных CelestaDoc-комментарии сохраняются.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_celestaunit">1.13. CelestaUnit</h3>
<div class="paragraph">
<p>Обычно автоматическое тестирование систем, редактирующих данные, представляет определённые сложности и требует использования специальных приёмов (например, развёртывание базы данных в контейнере). Такие тесты обычно выполняются не быстро и разработчики избегают их.</p>
</div>
<div class="paragraph">
<p>В Celesta тестирование методов, редактирующих данные, осуществляется на уровне очень быстро выполняющихся модульных тестов, для чего разработано расширение <a href="https://junit.org/junit5/">JUnit5</a>. Модульные тесты выполняются на встроенной непосредственно в Celesta базе H2, работающей в режиме in-memory. Эта база не требует установки, запускается моментально и исчезает после завершения тестов.</p>
</div>
<div class="paragraph">
<p>Чтобы воспользоваться данной функциональностью, необходимо добавить модуль celesta-unit Maven-зависимости проекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;ru.curs&lt;/groupId&gt;
    &lt;artifactId&gt;celesta-unit&lt;artifactId&gt;
    &lt;version&gt;...&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также в тестовый scope проекта необходимо добавить зависимости JUnit5 (примеры см. в <a href="https://junit.org/junit5/docs/current/user-guide/#dependency-metadata-junit-jupiter-samples">документации Junit5</a>).</p>
</div>
<div class="sect3">
<h4 id="_пример_пользования">1.13.1. Пример пользования</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/*Аннотация CelestaTest подключает JUnit5 extension class ru.curs.celestaunit.CelestaUnitExtension,
обеспечивающий подстановку CallContext-объектов в параметры тестов.*/
@CelestaTest
public class DocumentServiceTest {

    /*Сервис может быть создан как напрямую,
    так и используя DI контейнеры */

    DocumentService srv = new DocumentService();

    @Test
    /*Параметр CallContext будет подставлен автоматически,
    на основе временной базы данных H2*/
    void documentIsPutToDb(CallContext context) throws ParseException {
        /*Вызываем сервис*/
        srv.postOrder(context, ...);
        /*Проверяем, что данные попали в базу*/
        OrderHeaderCursor header = new OrderHeaderCursor(context);
        header.tryFirst();
        assertEquals("no1", header.getId());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Таким образом, каждый из тестов может получать в качестве параметра активный <code>CallContext</code>. Этот контекст формируется на основе базы данных H2, в которой развёрнута Celesta score, и может быть использован для создания курсоров.</p>
</div>
</div>
<div class="sect3">
<h4 id="_изменение_настроек_celestaunit_по_умолчанию">1.13.2. Изменение настроек CelestaUnit по умолчанию</h4>
<div class="paragraph">
<p>CelestaUnit работает со следующими умолчаниями:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Score path: <code>src/main/resources/score</code>.</p>
</li>
<li>
<p>Проверка ссылочной целостности (по Foreign keys) по умолчанию включена.</p>
</li>
<li>
<p>Очистка таблиц после каждого теста по умолчанию включена.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Изменить умолчания можно, воспользовавшись в тестовом классе <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-programmatic">программной регистрацией</a> расширения JUnit5:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class DocumentServiceTest {
    public static final String SCORE_PATH = "src/test/resources/score";
    @RegisterExtension
    static CelestaUnitExtension ext =
            CelestaUnitExtension.builder()
                    .withScorePath(SCORE_PATH)
                    .withReferentialIntegrity(true)
                    .withTruncateAfterEach(false).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, в ряде случаев бывает полезно отключить проверку ссылочной целостности, что упрощает добавление тестовых данных в таблицы, связанные внешними ключами с другими таблицами.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_celesta_и_базы_данных">2. Celesta и Базы данных</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="RDBMS_peculiarities">2.1. Особенности работы Celesta с поддерживаемыми типами СУБД</h3>
<div class="paragraph">
<p>Система по возможности прозрачно для разработчиков решения поддерживает MS SQL Server, Oracle, Postgre SQL и H2.</p>
</div>
<div class="paragraph">
<p>Хотя решения Celesta свободно переносимы между разными типами поддерживаемых СУБД, тем не менее, каждая из этих СУБД имеет особенности настройки. Кроме того, разные функциональные возможности Celesta по-разному реализованы в разных СУБД. Этим особенностям посвящён данный раздел.</p>
</div>
<div class="paragraph">
<p>Соответствие типов данных Celesta и СУБД приведено в разделе «Язык Celesta-SQL: типы данных».</p>
</div>
<div class="imageblock left">
<div class="content">
<img src="img/Mssql.jpg" alt="Mssql" width="80">
</div>
</div>
<div class="sect3">
<h4 id="_ms_sql_server">2.1.1. MS SQL Server</h4>
<div class="sect4">
<h5 id="_особенности_реализации">Особенности реализации</h5>
<div class="paragraph">
<p>Понятию «гранула» соответствует понятие «схема» (SCHEMA).</p>
</div>
<div class="imageblock left">
<div class="content">
<img src="img/Ora.jpg" alt="Ora" width="80">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_oracle">2.1.2. Oracle</h4>
<div class="sect4">
<h5 id="_особенности_настройки">Особенности настройки</h5>
<div class="paragraph">
<p><strong>Ошибка ORA-12705: Cannot access NLS data files&#8230;&#8203;</strong> Если при запуске Celesta на Oracle Express Edition возникает ошибка "ORA-12705: Cannot access NLS data files or invalid environment specified", в числе аргументов JVM необходимо задать параметр</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Duser.country=US</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если Celesta запускается из Flute или Showcase, то задать этот параметр можно на вкладке Java, поле Java Options программ Flute2w.exe или Tomcat7w.exe, используемых для управления сервисами Flute/Tomcat.</p>
</div>
<div class="paragraph">
<p>Эта проблема является общей для связки Oracle XE + JDBC и актуальна только для Oracle Express Edition, в прочих (production) версиях Oracle Database она не актуальна.</p>
</div>
<div class="paragraph">
<p>Минимальные настройки прав доступа для USER&#8217;а в БД <strong>Oracle 11g</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">GRANT
	CONNECT,
	RESOURCE,
	CREATE TABLE,
	CREATE PROCEDURE,
	CREATE VIEW,
	CREATE SEQUENCE,
	CREATE TRIGGER,
	SELECT ANY DICTIONARY
	TO &lt;USER&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В некоторых организациях по умолчанию не дают право доступа SELECT ANY DICTIONARY, из-за чего может возникать ошибка "ORA-00942: table or view does not exist" при разворачивании системной гранулы Celesta.</p>
</div>
</div>
<div class="sect4">
<h5 id="_особенности_реализации_2">Особенности реализации</h5>
<div class="ulist">
<ul>
<li>
<p>Гранула — префикс в имени таблицы, отделённый знаком подчёркивания, при этом работает ограничение Oracle на длину имени таблицы — 30 символов. Причина в том, что понятие «схема» в Oracle несколько отличается от такового для других СУБД, создание «схем» в Oracle связано с созданием новых пользователей, на что на практике не могут быть выданы права администраторами Oracle-серверов, на которых хранятся промышленные данные.</p>
</li>
<li>
<p>Oracle не поддерживает конструкцию FOREIGN KEY &#8230;&#8203; ON UPDATE/DELETE SET NULL, поэтому она эмулируется при помощи триггеров.</p>
</li>
</ul>
</div>
<div class="imageblock left">
<div class="content">
<img src="img/Postgre.png" alt="Postgre" width="120">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_postgresql">2.1.3. PostgreSQL</h4>
<div class="sect4">
<h5 id="_особенности_реализации_3">Особенности реализации</h5>
<div class="ulist">
<ul>
<li>
<p>Понятию «гранула» соответствует понятие «схема» (SCHEMA).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_особенности_использования">Особенности использования</h5>
<div class="paragraph">
<p>При использовании Celesta для доступа к существующей заранее (а не создаваемой и обновляемой в Celesta) базе данных может возникнуть проблема с полями типа uuid. Сама Celesta типа данных uuid как такового не поддерживает, но может работать с ним через поле типа VARCHAR(36). При этом не возникает проблем в MS SQL Server, но для работы Celesta в Postgres требуется явно определить оператор сравнения varchar с uuid и имплицитное изменение типов при присвоении:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE OR REPLACE FUNCTION celesta.uuidequal(a1 uuid, a2 CHARACTER VARYING)
  RETURNS BOOLEAN AS 'select a1::varchar = a2'
  LANGUAGE SQL IMMUTABLE;
CREATE OPERATOR = (
    LEFTARG = uuid,
    RIGHTARG = CHARACTER VARYING,
    PROCEDURE = celesta.uuidequal
);
CREATE CAST (character varying AS uuid)
    WITH  INOUT AS ASSIGNMENT;</code></pre>
</div>
</div>
<div class="imageblock left">
<div class="content">
<img src="img/H2.png" alt="H2" width="120">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_h2">2.1.4. H2</h4>
<div class="sect4">
<h5 id="_особенности_настройки_2">Особенности настройки</h5>
<div class="ulist">
<ul>
<li>
<p>Для упрощенной инициализации inmemory db в файл celesta.properties можно добавить настройку "h2.in-memory=true". В таком случае строка jdbc подключения будет игнорироваться, а также логин и пароль пользователя.</p>
</li>
<li>
<p>В celesta.properties добавлена поддержка настройки h2.referential.integrity=false(по умолчанию)/true. Выключенная настройка означает, что ограничения типа constraint будут проигнорированы при записи в БД. При включении ограничения будут обрабатываться как в других РСУБД. Для установки данной настройки не в inmemory БД пользователь должен обладать правами администратора(поле "ADMIN" в таблице "INFORMATION_SCHEMA.USERS") Данная настройка срабатывает один раз при инициализации приложения и для обновления требуется его перезапуск.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_особенности_реализации_4">Особенности реализации</h5>
<div class="ulist">
<ul>
<li>
<p>Понятию «гранула» соответствует понятие «схема» (SCHEMA).</p>
</li>
<li>
<p>Поля 'recversion' управляются триггером, написанном на Java и реализующим интерфейс org.h2.api.Trigger. H2 не поддерживает триггеры, логика которых заключена в процедурном SQL.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="DBSchema">2.2. Проектирование базы данных Celesta в DBSchema</h3>
<div class="sect3">
<h4 id="_синхронизация_метаданных_celesta_и_проекта_dbschema">2.2.1. Синхронизация метаданных Celesta и проекта DBSchema</h4>
<div class="paragraph">
<p><a href="http://www.dbschema.com/">DBSchema</a> представляет собой удобный инструмент визуального моделирования структуры базы данных. Имеется возможность полностью моделировать в DBSchema всю информацию Celesta о структуре БД (таблицы, поля, ключи, индексы), а также наоборот — превратить существующий Score в проект DBSchema.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/800px-Dbschemascreen.png" alt="800px Dbschemascreen" width="100%">
</div>
</div>
<div class="sect4">
<h5 id="_настройка_системы">Настройка системы</h5>
<div class="paragraph">
<p>Для работы вам понадобится:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>DBSchema (программа проприетарная, для работы необходимо приобретать лицензию).</p>
</li>
<li>
<p>Утилита <code>dbschemasync</code>.</p>
</li>
<li>
<p>Папка с настройками Celesta для DBSchema, которую надо поместить в %userprofile%\.DbSchema\config\rdbms\. В настройках прописаны шесть типов данных, доступных в Celesta.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Актуальную версию утилиты <code>dbschemasync</code> и папки с настройками для DBSchema (dbschemasync.zip) следует брать с Artifactory: <a href="https://artifactory.corchestra.ru/artifactory/list/corchestra-dev/" class="bare">https://artifactory.corchestra.ru/artifactory/list/corchestra-dev/</a></p>
</div>
</div>
<div class="sect4">
<h5 id="_запуск_синхронизации">Запуск синхронизации</h5>
<div class="paragraph">
<p>Утилита <code>dbschemasync</code> принимает два параметра:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Score path</p>
</li>
<li>
<p>имя DBS-файла (проекта DBSchema)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Направление синхронизации определяется последовательностью аргументов: если первым аргументом идёт Score Path, то синхронизация идёт от Score к проекту DBSchema, если же первым аргументом идёт имя проекта DBSchema, то синхронизация идёт от DBSchema к Score.</p>
</div>
<div class="paragraph">
<p>Пример команды для синхронизации от score к схеме:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>dbschemasync "c:/temp/dbschema/score/" "c:/temp/dbschema/schema.dbs"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пример синхронизации от схемы к score:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>dbschemasync "c:/temp/dbschema/schema.dbs" "c:/temp/dbschema/score/"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_особенности_работы_при_дизайне_структуры_бд">Особенности работы при дизайне структуры БД</h5>
<div class="paragraph">
<p>Всё, что находится в CelestaDoc, переводится в Documentation-поля DBSchema, и наоборот.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/800px-Dbschemascreen3.png" alt="800px Dbschemascreen3" width="100%">
</div>
</div>
<div class="paragraph">
<p>Опции таблицы (WITH (NO) VERSION CHECK, WITH READ ONLY&#8230;&#8203;) находятся на вкладке Storage:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Dbschemascreen4.png" alt="Dbschemascreen4" width="80%">
</div>
</div>
<div class="paragraph">
<p>В DBSchema, чтобы задать версию гранулы, необходимо модифицировать мнимую "хранимую процедуру", имеющую то же название, что и гранула (сами хранимые процедуры для Celesta в DBSchema, естественно, не моделируются):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Dbschemascreen2.png" alt="Dbschemascreen2" width="80%">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_создание_celestasql_скриптов_на_основе_структуры_существующей_бд">2.2.2. Создание CelestaSQL-скриптов на основе структуры существующей БД</h4>
<div class="paragraph">
<p>Эта технология рекомендована всем, у кого возникнет задача создания CelestaSQL-скриптов для уже существующей базы данных. Использование каких-либо иных путей (например, выгрузка SQL-скрипта из базы данных и ручная его "вычистка") по опыту является гораздо более трудоёмким занятием!</p>
</div>
<div class="paragraph">
<p>Для этого требуется программа DBSchema с установленной поддержкой Celesta. Шаги следующие:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Присоединяем DBSchema к нужной базе данных и методом Reverse Engineering закачиваем всю нужную нам структуру (на этом этапе можно ограничиться только теми таблицами и связями, которые нас интересуют в celesta). Убедитесь, что "забрали" все нужные таблицы, т. к. на следующих шагах проект придётся "отсоединить" от базы данных и автоматически получить сведения о таблицах уже не получится.</p>
</li>
<li>
<p>Отключаем DBSchema от базы данных (offline) и меняем тип базы с SQL Server на Celesta через меню Project-&#8594;Project Settings (естественно, предполагается, что к этому моменту в DBSchema установлена надстройка для синхронизации с Celesta из файла dbschemasetup.zip). Откроется окно, в котором DBSchema предложит сопоставить типы. Здесь надо всё правильно сделать: например, для SQL Server decimal(10,3) перевести в REAL, varchar(max) — в TEXT, uuid в varchar(36) и так далее.</p>
</li>
<li>
<p>После нажатия на OK мы получаем DBSchema-проект, ориентированный на Челесту (в этот момент его уместно сохранить в отдельном месте: он больше не привязан к исходной базе данных). Однако это — некорректный проект, т. к. нет деления на гранулы, гранулам не даны объявления, и, что главное — в нём ещё много фич, нехарактерных для Челесты. На этом этапе мы вручную должны создать гранулы (схемы) и разложить по ним таблицы.</p>
</li>
<li>
<p>Если теперь воспользоваться утилитой schemasync.jar, то мы, скорее всего, получим сообщения об ошибках, т. к. проект остаётся некорректным. Поэтому следует воспользоваться командой Schema-&#8594;Generate Schema Script для выгрузки всех таблиц в один sql-файл. Получившийся скрипт будет очень хорошим приближением к Celesta-скрипту, и вот это приближение уже удобно доделать вручную: убрать использование не поддерживаемых в Celesta функций, раздробить на разные файлы, что-то сделать с названиями длиннее 30 символов и т. д.</p>
</li>
<li>
<p>Настало время пробовать запускать Celesta с вашими скриптами.</p>
</li>
<li>
<p>Если вы дальше желаете использовать DBSchema, то лишь после того, как Celesta "согласится" работать с вашими скриптами, имеет смысл воспользоваться утилитой schemasync.jar для связи с абсолютно пустым проектом DBSchema ("промежуточный" проект DBSchema вы можете удалить). Это связано с тем, что в schemasync.jar встроен "челестовский" парсер SQL-скриптов, и он не сможет работать с тем, с чем не может работать сама Celesta.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_выгрузка_в_plantuml">2.2.3. Выгрузка в PlantUML</h4>
<div class="paragraph">
<p>Третья опция командной строки <code>-adoc</code> в режиме конвертации из DBSchema в score параллельно формирует диаграммы в формате <a href="https://habr.com/post/416077/">PlantUML</a> для каждой из диаграмм DBSchema. Имена файлов диаграмм соответствуют названиям листов DBSchema с диаграммами.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-11-09 12:07:33 UTC
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>